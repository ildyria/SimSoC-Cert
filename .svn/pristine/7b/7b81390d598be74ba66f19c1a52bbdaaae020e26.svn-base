--- sh4.txt	2011-12-23 19:51:48.624097566 +0100
+++ sh4inst.txt2	2011-12-24 05:29:25.528234703 +0100
@@ -9153,45 +9153,69 @@
                                                             Rev. 6.00 Sep 13, 2006 page 193 of 424
                                                                                  REJ09B0318-0600
 Section 9 Instruction Descriptions
+void Sleep_standby(void);
+/*void allocate_operand_cache_block(unsigned long);*/
+
+void fpu_exception_trap(void);
+void inexact(void);
+void invalidate_operand_cache_block(unsigned long);
+void if_is_dirty_block_then_write_back(unsigned long);
+void if_is_write_back_memory_and_look_up_in_operand_cache_eq_miss_then_allocate_operand_cache_block(unsigned long);
+void load_int(int, int);
+void load_quad(int, int);
+float sqrt(float);
+void store_int(int, int);
+void store_quad(int, int);
+void undefined_operation(void);
+/*void write_back(unsigned long);*/
+int bool_of_word(int);
+int nat_of_word(int);
+int int_of_float(float);
+int int64_of_string(char *);
 
   unsigned char          Read_Byte(unsigned long Addr);
   unsigned short Read_Word(unsigned long Addr);
   unsigned long          Read_Long(unsigned long Addr);
-  These reflect the respective sizes of address Addr. A word read from other than a 2n address, or a
-  longword read from other than a 4n address, will be detected as an address error.
+  /* These reflect the respective sizes of address Addr. A word read from other than a 2n address, or a
+  longword read from other than a 4n address, will be detected as an address error. */
 
 
-  unsigned char Write_Byte(unsigned long Addr, unsigned long Data);
-  unsigned short Write_Word(unsigned long Addr, unsigned long Data);
-  unsigned long Write_Long(unsigned long Addr, unsigned long Data);
-  These write data Data to address Addr, using the respective sizes. A word write to other than a 2n address,
-  or a longword write to other than a 4n address, will be detected as an address error.
+  void Write_Byte(unsigned long Addr, unsigned long Data);
+  void Write_Word(unsigned long Addr, unsigned long Data);
+  void Write_Long(unsigned long Addr, unsigned long Data);
+  /* These write data Data to address Addr, using the respective sizes. A word write to other than a 2n address,
+  or a longword write to other than a 4n address, will be detected as an address error. */
 
 
-  Delay_Slot(unsigned long Addr);
-  Shifts to execution of the slot instruction at address (Addr).
+  void Delay_Slot(unsigned long Addr);
+  /* Shifts to execution of the slot instruction at address (Addr). */
 
 
   unsigned long R[16];
+  union {
+    int ASID, VPN, PPN, SZ, SH, PR, WT, C, D, V, SA, TC;
+  } TLB_MMUCR_URC /* FIXME existence */; unsigned long PTEH, PTEL, PTEA;
   unsigned long SR,GBR,VBR;
+  unsigned long SSR, SPC, DBR, SGR, R0_BANK, R1_BANK, R2_BANK, R3_BANK, R4_BANK, R5_BANK, R6_BANK, R7_BANK, TRA, SR_MD, SR_BL, SR_RB, EXPEVT, H_00000100; /* FIXME existence */
   unsigned long MACH,MACL,PR;
   unsigned long PC;
-  Registers
+  float FPUL;
+  /* Registers */
 
 
-  struct SR0 {
-     unsigned long dummy0:22;
-     unsigned long               M0:1;
-     unsigned long               Q0:1;
-     unsigned long               I0:4;
-     unsigned long dummy1:2;
-     unsigned long               S0:1;
-     unsigned long               T0:1;
+  struct SR0 { /* FIXME determine if "int" can really be a substitute for "unsigned long" */
+     /*int dummy0:22;*/
+     int               M0:1;
+     int               Q0:1;
+     /*int               I0:4;*/
+     /*int dummy1:2;*/
+     int               S0:1;
+     int               T0:1;
   };
-  SR structure definitions
+  /* SR structure definitions */
 
 
-  define M ((*(struct SR0 *)(&SR)).M0)
+  #define M ((*(struct SR0 *)(&SR)).M0)
   #define Q ((*(struct SR0 *)(&SR)).Q0)
   #define S ((*(struct SR0 *)(&SR)).S0)
 
@@ -9201,14 +9225,14 @@
                                                                Section 9 Instruction Descriptions
 
 #define T ((*(struct SR0 *)(&SR)).T0)
-Definitions of bits in SR
+/* Definitions of bits in SR */
 
 
-Error( char *er );
-Error display function
+void Error( char *er );
+/* Error display function */
 
 
-These are floating-point number definition statements.
+/* These are floating-point number definition statements. */
 #define PZERO                0
 #define NZERO                1
 #define DENORM               2
@@ -9248,12 +9272,14 @@
   #define FLAG              0x0000007C    /* FPSCR(bit6-2) */
 
 
-  #define FPSCR_FR          FPSCR>>21&1
-  #define FPSCR_PR          FPSCR>>19&1
-  #define FPSCR_DN          FPSCR>>18&1
+  #define FPSCR_FR          nat_of_word(FPSCR>>21&1)
+  #define FPSCR_PR          bool_of_word(FPSCR>>19&1)
+  #define FPSCR_DN          bool_of_word(FPSCR>>18&1)
   #define FPSCR_I           FPSCR>>12&1
   #define FPSCR_RM          FPSCR&1
+  #define SPSCR_RM          FPSCR&1 /* FIXME existence */
   #define FR_HEX            frf.l[ FPSCR_FR]
+  #define DR_HEX            frf.l[ FPSCR_FR] /* FIXME existence */
   #define FR                frf.f[ FPSCR_FR]
   #define DR                frf.d[ FPSCR_FR]
   #define XF_HEX            frf.l[~FPSCR_FR]
@@ -9273,6 +9299,16 @@
   {
           return(FR_HEX[n]>>31);
   }
+
+/* Remark : According to the C compcert compiler, function needs to be declared before their use (otherwise, they will by default have type int as return type). */
+
+void zero(int n, int sign)
+{
+     if(sign == 0)      FR_HEX [n]     = 0x00000000;
+     else               FR_HEX [n]     = 0x80000000;
+     if (bool_of_word(FPSCR_PR)==1) FR_HEX [n+1] = 0x00000000;
+}
+
   int data_type_of(int n) {
   int abs;
         abs = FR_HEX[n] & 0x7fffffff;
@@ -9300,7 +9336,7 @@
      else {       /* Double-precision */
          if(abs < 0x00100000){
                 if((FPSCR_DN == 1) ||
-                    ((abs == 0x00000000) && (FR_HEX[n+1] == 0x00000000)){
+                    (abs == 0x00000000) && (FR_HEX[nat_of_word(n+1)] == 0x00000000)){
                       if(sign_of(n) == 0)       {zero(n, 0); return(PZERO);}
                       else                      {zero(n, 1); return(NZERO);}
               }
@@ -9308,7 +9344,7 @@
          }
          else if(abs < 0x7ff00000) return(NORM);
          else if((abs == 0x7ff00000) &&
-                      (FR_HEX[n+1] == 0x00000000)) {
+                      (FR_HEX[nat_of_word(n+1)] == 0x00000000)) {
                 if(sign_of(n) == 0) return(PINF);
                 else                       return(NINF);
          }
@@ -9316,18 +9352,114 @@
          else                                return(sNaN);
      }
 }
-void register_copy(int m,n)
+void register_copy(int m, int n)
 {
                                 FR[n]      = FR[m];
      if(FPSCR_PR == 1)          FR[n+1] = FR[m+1];
 }
-void normal_faddsub(int m,n,type)
+
 
                                                   Rev. 6.00 Sep 13, 2006 page 197 of 424
                                                                        REJ09B0318-0600
 Section 9 Instruction Descriptions
 
+  void set_V() {FPSCR |= SET_V;}
+  void set_O() {FPSCR |= SET_O;}
+  void set_U() {FPSCR |= SET_U;}
+  void set_I() {FPSCR |= SET_I;}
+void qnan(int n)
+{
+     if (FPSCR_PR==0)    FR[n]   = 0x7fbfffff;
+     else {              FR[n]   = 0x7ff7ffff;
+                         FR[n+1] = 0xffffffff;
+     }
+}
+  void invalid(int n)
+  {
+         set_V();
+         if((FPSCR & ENABLE_V) == 0) qnan(n);
+     else     fpu_exception_trap();
+}
+void inf(int n, int sign) {
+     if (FPSCR_PR==0) {
+         if(sign == 0)    FR_HEX [n]     = 0x7f800000;
+         else             FR_HEX [n]     = 0xff800000;
+     } else {
+         if(sign == 0)    FR_HEX [n]     = 0x7ff00000;
+         else             FR_HEX [n]     = 0xfff00000;
+                          FR_HEX [n+1] = 0x00000000;
+     }
+}
+
+  void check_single_exception(float *dst, float result)
+  {
+  union {
+        float f;
+        int l;
+  }     tmp;
+  float abs;
+        if(result < 0.0)        tmp.l = 0xff800000; /* – infinity */
+        else                    tmp.l = 0x7f800000; /* + infinity */
+        if(result == tmp.f) {
+               set_O(); set_I();
+               if(FPSCR_RM == 1)          {
+                   tmp.l -= 1; /* Maximum value of normalized number */
+                   result = tmp.f;
+               }
+        }
+        if(result < 0.0)        abs = -result;
+        else                    abs =    result;
+        tmp.l = 0x00800000; /* Minimum value of normalized number */
+        if(abs < tmp.f) {
+               if((FPSCR_DN == 1) && (abs != 0.0)) {
+                   set_I();
+                   if(result < 0.0) result = -0.0; /* Zeroize denormalized number */
+                   else                  result =   0.0;
+               }
+               if(FPSCR_I == 1) set_U();
+        }
+        if(FPSCR & ENABLE_OUI) fpu_exception_trap();
+        else                            *dst = result;
+  }
+
+  void check_double_exception(double *dst, float result)
+  {
+  union {
+        double d;
+        int l[2];
+}    tmp;
+double abs;
+     if(result < 0.0)        tmp.l[0] = 0xfff00000; /* – infinity */
+     else                    tmp.l[0] = 0x7ff00000; /* + infinity */
+                             tmp.l[1] = 0x00000000;
+     if(result == tmp.d) {
+            set_O(); set_I();
+            if(FPSCR_RM == 1) {
+                  tmp.l[0] -= 1;
+                  tmp.l[1] = 0xffffffff;
+                 result = tmp.d; /* Maximum value of normalized number */
+            }
+     }
+     if(result < 0.0)        abs = -result;
+     else                    abs =    result;
+     tmp.l[0] = 0x00100000; /* Minimum value of normalized number */
+     tmp.l[1] = 0x00000000;
+     if(abs < tmp.d) {
+         if((FPSCR_DN == 1) && (abs != 0.0)) {
+                  set_I();
+                  if(result < 0.0) result = -0.0;
+                                 /* Zeroize denormalized number */
+                  else                result =   0.0;
+         }
+         if(FPSCR_I == 1) set_U();
+     }
+     if(FPSCR & ENABLE_OUI) fpu_exception_trap();
+     else                            *dst = result;
+}
+
+void normal_faddsub(int m, int n, int type)
   {
+  int dst_d /* FIXME do we have to declare dst_d ? */;
   union {
         float f;
         int l;
@@ -9337,7 +9469,7 @@
         int l[2];
   }     dstd,srcd;
   union {                      /* “long double” format:      */
-        long double x;         /*    1-bit sign         */
+        /*long*/ double x; /* FIXME long double unsupported by compcert */        /*    1-bit sign         */
         int l[4];              /*    15-bit exponent    */
   }     dstx;                  /*    112-bit mantissa */
         if(FPSCR_PR == 0) {
@@ -9382,16 +9514,16 @@
               }
           }
           if((dstx.l[2] & 0x0fffffff) || dstx.l[3]) set_I();
-          dst.d += srcd.d; /* Round to nearest */
+          dst_d += srcd.d; /* Round to nearest */
           if(FPSCR_RM == 1) {
               dstx.l[2] &= 0xf0000000; /* Round to zero */
               dstx.l[3]     = 0x00000000;
-              dst.d = dstx.x;
+              dst_d = dstx.x;
           }
-          check_double_exception(&DR[n>>1] ,dst.d);
+          check_double_exception(&DR[n>>1] ,dst_d);
      }
 }
-void normal_fmul(int m,n)
+void normal_fmul(int m, int n)
 {
 union {
      float f;
@@ -9407,7 +9539,7 @@
                                                                         REJ09B0318-0600
 Section 9 Instruction Descriptions
 
-        long double x;
+        /*long*/ double x; /* FIXME long double unsupported by compcert */
         int l[4];
   }     tmpx;
         if(FPSCR_PR == 0) {
@@ -9424,14 +9556,50 @@
               tmpx.x *= DR[m>>1]; /* Precise creation */
               tmpd.d *= DR[m>>1]; /* Round to nearest */
               if(tmpd.d != tmpx.x) set_I();
-              if(tmpd.d > tmpx.x) && (FPSCR_RM == 1)) {
+              if(tmpd.d > tmpx.x && (FPSCR_RM == 1)) {
                    tmpd.l[1] -= 1; /* Round to zero */
                    if(tmpd.l[1] == 0xffffffff) tmpd.l[0] -= 1;
               }
               check_double_exception(&DR[n>>1], tmpd.d);
         }
   }
-  void fipr(int m,n)
+
+  int check_product_infinity(int m, int n)
+  {
+         return((data_type_of(m) == PINF) || (data_type_of(n) == PINF) ||
+                 (data_type_of(m) == NINF) || (data_type_of(n) == NINF));
+  }
+
+  int check_negative_infinity(int m, int n)
+  {
+    return((check_product_infinity(m,n) && (sign_of(m)^ sign_of(n))) ||
+       (check_product_infinity(m+1,n+1) && (sign_of(m+1)^
+  sign_of(n+1))) ||
+       (check_product_infinity(m+2,n+2) && (sign_of(m+2)^
+  sign_of(n+2))) ||
+       (check_product_infinity(m+3,n+3) && (sign_of(m+3)^
+                                            sign_of(n+3))));
+  }
+  int check_positive_infinity(int m, int n)
+  {
+    return((check_product_infinity(m,n) && (~sign_of(m)^
+  sign_of(n))) ||
+       (check_product_infinity(m+1,n+1) && (~sign_of(m+1)^
+  sign_of(n+1))) ||
+       (check_product_infinity(m+2,n+2) && (~sign_of(m+2)^
+  sign_of(n+2))) ||
+       (check_product_infinity(m+3,n+3) && (~sign_of(m+3)^
+                                            sign_of(n+3))));
+  }
+
+int check_product_invalid(int m, int n)
+{
+     return(check_product_infinity(m,n)           &&
+                ((data_type_of(m) == PZERO) || (data_type_of(n) == PZERO) ||
+                 (data_type_of(m) == NZERO) || (data_type_of(n) == NZERO)));
+}
+
+  void fipr(int m, int n)
   {
   union {
         double d;
@@ -9456,11 +9624,12 @@
            (data_type_of(m+2) == qNaN) || (data_type_of(n+2) == qNaN) ||
          (data_type_of(m+3) == qNaN) || (data_type_of(n+3) == qNaN))
 qnan(n+3);
-     else if (check_ positive_infinity() &&
-                 (check_ negative_infinity())                        invalid(n+3);
-     else if (check_ positive_infinity())                              inf(n+3,0);
-     else if (check_ negative_infinity())                              inf(n+3,1);
+     else if (check_positive_infinity(m, n) /* FIXME m or n ? */ &&
+                 check_negative_infinity(m, n) /* FIXME m or n ? */)                        invalid(n+3);
+     else if (check_positive_infinity(m, n) /* FIXME m or n ? */)                              inf(n+3,0);
+     else if (check_negative_infinity(m, n) /* FIXME m or n ? */)                              inf(n+3,1);
      else {
+           int i;
            for(i=0;i<4;i++) {
                  /* If FPSCR_DN == 1, zeroize */
                  if        (data_type_of(m+i) == PZERO)                 FR[m+i] = +0.0;
@@ -9489,161 +9658,30 @@
                                                                                  REJ09B0318-0600
 Section 9 Instruction Descriptions
 
-  void check_single_exception(float *dst,result)
-  {
-  union {
-        float f;
-        int l;
-  }     tmp;
-  float abs;
-        if(result < 0.0)        tmp.l = 0xff800000; /* – infinity */
-        else                    tmp.l = 0x7f800000; /* + infinity */
-        if(result == tmp.f) {
-               set_O(); set_I();
-               if(FPSCR_RM == 1)          {
-                   tmp.l -= 1; /* Maximum value of normalized number */
-                   result = tmp.f;
-               }
-        }
-        if(result < 0.0)        abs = -result;
-        else                    abs =    result;
-        tmp.l = 0x00800000; /* Minimum value of normalized number */
-        if(abs < tmp.f) {
-               if((FPSCR_DN == 1) && (abs != 0.0)) {
-                   set_I();
-                   if(result < 0.0) result = -0.0; /* Zeroize denormalized number */
-                   else                  result =   0.0;
-               }
-               if(FPSCR_I == 1) set_U();
-        }
-        if(FPSCR & ENABLE_OUI) fpu_exception_trap();
-        else                            *dst = result;
-  }
-  void check_double_exception(double *dst,result)
-  {
-  union {
-        double d;
-        int l[2];
 
 Rev. 6.00 Sep 13, 2006 page 202 of 424
 REJ09B0318-0600
                                                         Section 9 Instruction Descriptions
 
-}    tmp;
-double abs;
-     if(result < 0.0)        tmp.l[0] = 0xfff00000; /* – infinity */
-     else                    tmp.l[0] = 0x7ff00000; /* + infinity */
-                             tmp.l[1] = 0x00000000;
-     if(result == tmp.d)
-            set_O(); set_I();
-            if(FPSCR_RM == 1) {
-                  tmp.l[0] -= 1;
-                  tmp.l[1] = 0xffffffff;
-                 result = tmp.d; /* Maximum value of normalized number */
-            }
-     }
-     if(result < 0.0)        abs = -result;
-     else                    abs =    result;
-     tmp.l[0] = 0x00100000; /* Minimum value of normalized number */
-     tmp.l[1] = 0x00000000;
-     if(abs < tmp.d) {
-         if((FPSCR_DN == 1) && (abs != 0.0)) {
-                  set_I();
-                  if(result < 0.0) result = -0.0;
-                                 /* Zeroize denormalized number */
-                  else                result =   0.0;
-         }
-         if(FPSCR_I == 1) set_U();
-     }
-     if(FPSCR & ENABLE_OUI) fpu_exception_trap();
-     else                            *dst = result;
-}
-int check_product_invalid(int m,n)
-{
-     return(check_product_infinity(m,n)           &&
-                ((data_type_of(m) == PZERO) || (data_type_of(n) == PZERO) ||
-                 (data_type_of(m) == NZERO) || (data_type_of(n) == NZERO)));
-}
 
                                                   Rev. 6.00 Sep 13, 2006 page 203 of 424
                                                                        REJ09B0318-0600
 Section 9 Instruction Descriptions
 
-  int check_ product_infinity(int m,n)
-  {
-         return((data_type_of(m) == PINF) || (data_type_of(n) == PINF) ||
-                 (data_type_of(m) == NINF) || (data_type_of(n) == NINF));
-  }
-  int check_ positive_infinity(int m,n)
-  {
-       return(((check_ product_infinity(m,n) && (~sign_of(m)^
-  sign_of(n))) ||
-       ((check_ product_infinity(m+1,n+1) && (~sign_of(m+1)^
-  sign_of(n+1))) ||
-       ((check_ product_infinity(m+2,n+2) && (~sign_of(m+2)^
-  sign_of(n+2))) ||
-       ((check_ product_infinity(m+3,n+3) && (~sign_of(m+3)^
-  sign_of(n+3))));
-  }
-  int check_ negative_infinity(int m,n)
-  {
-      return(((check_ product_infinity(m,n) && (sign_of(m)^ sign_of(n))) ||
-       ((check_ product_infinity(m+1,n+1) && (sign_of(m+1)^
-  sign_of(n+1))) ||
-       ((check_ product_infinity(m+2,n+2) && (sign_of(m+2)^
-  sign_of(n+2))) ||
-       ((check_ product_infinity(m+3,n+3) && (sign_of(m+3)^
-  sign_of(n+3))));
-  }
   void clear_cause () {FPSCR &= ~CAUSE;}
   void set_E() {FPSCR |= SET_E; fpu_exception_trap();}
-  void set_V() {FPSCR |= SET_V;}
   void set_Z() {FPSCR |= SET_Z;}
-  void set_O() {FPSCR |= SET_O;}
-  void set_U() {FPSCR |= SET_U;}
-  void set_I() {FPSCR |= SET_I;}
-  void invalid(int n)
-  {
-         set_V();
-         if((FPSCR & ENABLE_V) == 0 qnan(n);
 
 Rev. 6.00 Sep 13, 2006 page 204 of 424
 REJ09B0318-0600
                                                   Section 9 Instruction Descriptions
 
-     else     fpu_exception_trap();
-}
-
-
-void dz(int n,sign)
+void dz(int n, int sign)
 {
      set_Z();
-     if((FPSCR & ENABLE_Z) == 0 inf(n,sign);
+     if((FPSCR & ENABLE_Z) == 0) inf(n,sign);
      else     fpu_exception_trap();
 }
-void zero(int n,sign)
-{
-     if(sign == 0)      FR_HEX [n]     = 0x00000000;
-     else               FR_HEX [n]     = 0x80000000;
-     if (FPSCR_PR==1) FR_HEX [n+1] = 0x00000000;
-}
-void inf(int n,sign) {
-     if (FPSCR_PR==0) {
-         if(sign == 0)    FR_HEX [n]     = 0x7f800000;
-         else             FR_HEX [n]     = 0xff800000;
-     } else {
-         if(sign == 0)    FR_HEX [n]     = 0x7ff00000;
-         else             FR_HEX [n]     = 0xfff00000;
-                          FR_HEX [n+1] = 0x00000000;
-     }
-}
-void qnan(int n)
-{
-     if (FPSCR_PR==0)    FR[n]   = 0x7fbfffff;
-     else {              FR[n]   = 0x7ff7ffff;
-                         FR[n+1] = 0xffffffff;
-     }
-}
 
 
 
@@ -10662,7 +10700,7 @@
 Section 9 Instruction Descriptions
 
        LL=temp&0x000000FF;
-       HH=HH&&HL&&LH&&LL;
+       HH=HH&HL&LH&LL;
        if (HH==0) T=1;
        else T=0;
        PC+=2;
@@ -10674,8 +10712,8 @@
        long imm;
 
 
-       if ((i&0x80)==0) imm=(0x000000FF & (long i));
-       else imm=(0xFFFFFF00 | (long i));
+       if ((i&0x80)==0) imm=(0x000000FF & i);
+       else imm=(0xFFFFFF00 | i);
        if (R[0]==imm) T=1;
        else T=0;
        PC+=2;
@@ -11031,13 +11069,13 @@
 
 
            if (fnLmL<0) {
-                        ~
-                 Res2= Res2;
+                        
+                 Res2=!Res2;
                  if (Res0==0)
                     Res2++;
                  else
-                            ~
-                    Res0=( Res0)+1;
+                            
+                    Res0=(!Res0)+1;
            }
 
 
@@ -11099,7 +11137,7 @@
        temp3=RmH*RnH;
 
 
-       Res2=0
+       Res2=0;
        Res1=temp1+temp2;
 
 
@@ -11311,9 +11349,9 @@
 Operation
 
     void FABS (int n){
-           FR[n] = FR[n] & 0x7fffffff;
-           pc += 2;
-    }
+      FR[n] = ((int) FR[n]) & 0x7fffffff; /* FIXME s'agit-il de convertir FR[n] en int ou l'autre nombre en float ? */
+           PC += 2;
+    } 
     /* Same operation is performed regardless of precision. */
 
 Possible Exceptions:
@@ -11351,9 +11389,9 @@
 
 Operation
 
-    void FADD (int m,n)
-    {
-         pc += 2;
+   void FADD_(int m, int n) /* FADD is a "#define" symbol, so we have to rename the name of this function */
+   {
+         PC += 2;
          clear_cause();
          if((data_type_of(m) == sNaN) ||
               (data_type_of(n) == sNaN)) invalid(n);
@@ -11363,7 +11401,7 @@
                    (data_type_of(n) == DENORM)) set_E();
          else switch (data_type_of(m)){
               case NORM: switch (data_type_of(n)){
-                   case NORM:         normal_faddsub(m,n,ADD); break;
+                   case NORM:         normal_faddsub(m,n,FADD); break;
                    case PZERO:
 
 
@@ -11451,29 +11489,12 @@
 
 Operation
 
-     void FCMP_EQ(int m,n) /* FCMP/EQ         FRm,FRn */
-     {
-             pc += 2;
-             clear_cause();
-             if(fcmp_chk (m,n) == INVALID) fcmp_invalid();
-             else if(fcmp_chk (m,n) == EQ)       T = 1;
-             else                                T = 0;
-     }
-     void FCMP_GT(int m,n) /* FCMP/GT         FRm,FRn */
-     {
-             pc += 2;
-             clear_cause();
-             if ((fcmp_chk (m,n) == INVALID) ||
-
-                                                       Rev. 6.00 Sep 13, 2006 page 257 of 424
-                                                                            REJ09B0318-0600
-Section 9 Instruction Descriptions
-
-               (fcmp_chk (m,n) == UO)) fcmp_invalid();
-        else if(fcmp_chk (m,n) == GT)          T = 1;
-        else                                   T = 0;
-  }
-  int fcmp_chk (int m,n)
+void fcmp_invalid()
+{
+     set_V();     if((FPSCR & ENABLE_V) == 0)    T = 0;
+                  else fpu_exception_trap();
+}
+  int fcmp_chk (int m, int n)
   {
         if((data_type_of(m) == sNaN) ||
             (data_type_of(n) == sNaN))                 return(INVALID);
@@ -11504,24 +11525,39 @@
               if(FR[n] == FR[m])                 return(EQ);
               else if(FR[n] > FR[m])             return(GT);
               else                               return(LT);
-
-Rev. 6.00 Sep 13, 2006 page 258 of 424
-REJ09B0318-0600
-                                                Section 9 Instruction Descriptions
-
      }else {
          if(DR[n>>1] == DR[m>>1])     return(EQ);
          else if(DR[n>>1] > DR[m>>1]) return(GT);
          else                         return(LT);
      }
 }
-void fcmp_invalid()
-{
-     set_V();     if((FPSCR & ENABLE_V) == 0)    T = 0;
-                  else fpu_exception_trap();
-}
 
+     void FCMP_EQ(int m, int n) /* FCMP/EQ         FRm,FRn */
+     {
+             PC += 2;
+             clear_cause();
+             if(fcmp_chk (m,n) == INVALID) fcmp_invalid();
+             else if(fcmp_chk (m,n) == EQ)       T = 1;
+             else                                T = 0;
+     }
+     void FCMP_GT(int m, int n) /* FCMP/GT         FRm,FRn */
+     {
+             PC += 2;
+             clear_cause();
+             if ((fcmp_chk (m,n) == INVALID) ||
+
+                                                       Rev. 6.00 Sep 13, 2006 page 257 of 424
+                                                                            REJ09B0318-0600
+Section 9 Instruction Descriptions
 
+               (fcmp_chk (m,n) == UO)) fcmp_invalid();
+        else if(fcmp_chk (m,n) == GT)          T = 1;
+        else                                   T = 0;
+  }
+
+Rev. 6.00 Sep 13, 2006 page 258 of 424
+REJ09B0318-0600
+                                                Section 9 Instruction Descriptions
 
 
                                         Rev. 6.00 Sep 13, 2006 page 259 of 424
@@ -11591,34 +11627,9 @@
 
 Operation
 
-    void FCNVDS(int m, float *FPUL){
-            case((FPSCR.PR){
-                 0:    undefined_operation();            /* reserved */
-                 1:    fcnvds(m, *FPUL);        break;     /* FCNVDS */
-            }
-    }
-    void fcnvds(int m, float *FPUL)
-    {
-            pc += 2;
-            clear_cause();
-            case(data_type_of(m, *FPUL)){
-                 NORM    :
-                 PZERO :
-                 NZERO :          normal_ fcnvds(m, *FPUL);        break;
-                 DENORM : set_E();
-
-                                                          Rev. 6.00 Sep 13, 2006 page 261 of 424
-                                                                               REJ09B0318-0600
-Section 9 Instruction Descriptions
-
-               PINF    :     *FPUL = 0x7f800000; break;
-               NINF    :     *FPUL = 0xff800000; break;
-               qNaN    :     *FPUL = 0x7fbfffff; break;
-               sNaN    :       set_V();
-                                 if((FPSCR & ENABLE_V) == 0) *FPUL = 0x7fbfffff;
-                                 else fpu_exception_trap();   break;
-        }
-  }
+int data_type_of_2(int n1, int n2) {
+  return 0 ; /* FIXME écrire la fonction */
+}
   void normal_fcnvds(int m, float *FPUL)
   {
   int sign;
@@ -11632,13 +11643,38 @@
           int l[2];
   }       dstd;
           dstd.d = DR[m>>1];
-          if(dstd.l[1] & 0x1fffffff)) set_I();
+          if(dstd.l[1] & 0x1fffffff) set_I();
           if(FPSCR_RM == 1) dstd.l[1] &= 0xe0000000; /* round toward zero*/
           dstf.f = dstd.d;
           check_single_exception(FPUL, dstf.f);
   }
+    void fcnvds(int m, float *FPUL)
+    {
+            PC += 2;
+            clear_cause();
+    switch (data_type_of_2(m, *FPUL)) {
+                 case NORM    :
+                 case PZERO :
+                 case NZERO :          normal_fcnvds(m, FPUL);        break;
+                 case DENORM : set_E();
+               case PINF    :     *FPUL = 0x7f800000; break;
+               case NINF    :     *FPUL = 0xff800000; break;
+               case qNaN    :     *FPUL = 0x7fbfffff; break;
+               case sNaN    :       set_V();
+                                 if((FPSCR & ENABLE_V) == 0) *FPUL = 0x7fbfffff;
+                                 else fpu_exception_trap();   break;
+        }
+  }
 
-
+    void FCNVDS(int m, float *FPUL){
+            switch(FPSCR_PR){
+                 case 0:    undefined_operation();            /* reserved */
+                 case 1:    fcnvds(m, FPUL);        break;     /* FCNVDS */
+            }
+    }
+                                                          Rev. 6.00 Sep 13, 2006 page 261 of 424
+                                                                               REJ09B0318-0600
+Section 9 Instruction Descriptions
 
 
 Rev. 6.00 Sep 13, 2006 page 262 of 424
@@ -11678,42 +11714,17 @@
 1       FCNVSD FPUL, DRn          (double) FPUL → DRn     1111nnn010101101 2             —
 
 
-Description
-
-When FPSCR.PR = 1: This instruction converts the single-precision floating-point number in
-FPUL to a double-precision floating-point number, and stores the result in DRn.
-
-Operation
-
-    void FCNVSD(int n, float *FPUL){
-            pc += 2;
-            clear_cause();
-            case((FPSCR_PR){
-                 0:    undefined_operation();            /* reserved */
-                 1:    fcnvsd (n, *FPUL);        break;       /* FCNVSD */
-            }
-    }
-    void fcnvsd(int n, float *FPUL)
-    {
-            case(fpul_type(FPUL)){
-                 PZERO :
-                 NZERO :
-                 PINF    :
-                 NINF    :            DR[n>>1] = *FPUL;          break;
-                 DENORM :     set_E();                  break;
-                 qNaN    :            qnan(n);          break;
-                 sNaN    :            invalid(n);                break;
-            }
+Description
 
-Rev. 6.00 Sep 13, 2006 page 264 of 424
-REJ09B0318-0600
-                                                              Section 9 Instruction Descriptions
+When FPSCR.PR = 1: This instruction converts the single-precision floating-point number in
+FPUL to a double-precision floating-point number, and stores the result in DRn.
 
-  }
-  int fpul_type(int *FPUL)
+Operation
+
+  int fpul_type(int FPUL)
   {
-  int abs;
-        abs = *FPUL & 0x7fffffff;
+    int abs, src;
+        abs = FPUL & 0x7fffffff;
         if(abs < 0x00800000){
               if((FPSCR_DN == 1) || (abs == 0x00000000)){
                   if(sign_of(src) == 0) return(PZERO);
@@ -11730,6 +11741,31 @@
         else                              return(sNaN);
   }
 
+    void fcnvsd(int n, float *FPUL)
+    {
+            switch(fpul_type(int_of_float(*FPUL))){
+                 case PZERO :
+                 case NZERO :
+            case PINF    :
+            case NINF    :            DR[n>>1] = *FPUL;          break;
+            case DENORM :     set_E();                  break;
+            case qNaN    :            qnan(n);          break;
+            case sNaN    :            invalid(n);                break;
+            }
+  }
+    void FCNVSD(int n, float *FPUL){
+            PC += 2;
+            clear_cause();
+            switch (FPSCR_PR){
+                 case 0:    undefined_operation();            /* reserved */
+                 case 1:    fcnvsd (n, FPUL);        break;       /* FCNVSD */
+            }
+    }
+ 
+Rev. 6.00 Sep 13, 2006 page 264 of 424
+REJ09B0318-0600
+                                                              Section 9 Instruction Descriptions
+
 FCNVSD Special Cases
 
         FRn            +NORM      –NORM       +0    –0       +INF     –INF     qNaN     sNaN
@@ -11772,10 +11808,46 @@
 therefore be performed by software.
 
 Operation
+void normal_fdiv(int m, int n)
+{
+union {
+      float f;
+      int l;
+}     dstf,tmpf;
+union {
+      double d;
+          int l[2];
+  }       dstd,tmpd;
+  union {
+    /*int*/ double x;
+          int l[4];
+  }       tmpx;
+        if(FPSCR_PR == 0) {
+              tmpf.f = FR[n]; /* save destination value */
+              dstf.f /= FR[m]; /* round toward nearest or even */
+              tmpd.d = dstf.f; /* convert single to double */
+              tmpd.d *= FR[m];
+              if(tmpf.f != tmpd.d) set_I();
+              if((tmpf.f < tmpd.d) && (SPSCR_RM == 1))
+                   dstf.l -= 1; /* round toward zero */
+               check_single_exception(&FR[n], dstf.f);
+        } else {
+              tmpd.d = DR[n>>1]; /* save destination value */
+              dstd.d /= DR[m>>1]; /* round toward nearest or even */
+              tmpx.x = dstd.d; /* convert double to int double */
+              tmpx.x *= DR[m>>1];
+              if(tmpd.d != tmpx.x) set_I();
+              if((tmpd.d < tmpx.x) && (SPSCR_RM == 1)) {
+                   dstd.l[1] -= 1; /* round toward zero */
+                   if(dstd.l[1] == 0xffffffff) dstd.l[0] -= 1;
+              }
+              check_double_exception(&DR[n>>1], dstd.d);
+        }
+  }
 
-    void FDIV(int m,n)           /* FDIV FRm,FRn */
+    void FDIV(int m, int n)           /* FDIV FRm,FRn */
     {
-         pc += 2;
+         PC += 2;
          clear_cause();
          if((data_type_of(m) == sNaN) ||
               (data_type_of(n) == sNaN)) invalid(n);
@@ -11816,54 +11888,15 @@
                case DENORM: set_E(); break;
                case PINF:
                case NINF: invalid(n);           break;
-               default:      zero(n,sign_of(m)^sign_of(n));break
+                       default:      zero(n,sign_of(m)^sign_of(n));break;
                }       break;
           }
 }
-void normal_fdiv(int m,n)
-{
-union {
-      float f;
-      int l;
-}     dstf,tmpf;
-union {
-      double d;
 
                                                 Rev. 6.00 Sep 13, 2006 page 267 of 424
                                                                      REJ09B0318-0600
 Section 9 Instruction Descriptions
 
-          int l[2];
-  }       dstd,tmpd;
-  union {
-          int double x;
-          int l[4];
-  }       tmpx;
-        if(FPSCR_PR == 0) {
-              tmpf.f = FR[n]; /* save destination value */
-              dstf.f /= FR[m]; /* round toward nearest or even */
-              tmpd.d = dstf.f; /* convert single to double */
-              tmpd.d *= FR[m];
-              if(tmpf.f != tmpd.d) set_I();
-              if((tmpf.f < tmpd.d) && (SPSCR_RM == 1))
-                   dstf.l -= 1; /* round toward zero */
-               check_single_exception(&FR[n], dstf.f);
-        } else {
-              tmpd.d = DR[n>>1]; /* save destination value */
-              dstd.d /= DR[m>>1]; /* round toward nearest or even */
-              tmpx.x = dstd.d; /* convert double to int double */
-              tmpx.x *= DR[m>>1];
-              if(tmpd.d != tmpx.x) set_I();
-              if((tmpd.d < tmpx.x) && (SPSCR_RM == 1)) {
-                   dstd.l[1] -= 1; /* round toward zero */
-                   if(dstd.l[1] == 0xffffffff) dstd.l[0] -= 1;
-              }
-              check_double_exception(&DR[n>>1], dstd.d);
-        }
-  }
-
-
-
 
 Rev. 6.00 Sep 13, 2006 page 268 of 424
 REJ09B0318-0600
@@ -11954,10 +11987,10 @@
 
 Operation
 
-  void FIPR(int m,n)          /* FIPR FVm,FVn */
+  void FIPR(int m, int n)          /* FIPR FVm,FVn */
   {
          if(FPSCR_PR == 0) {
-              pc += 2;
+              PC += 2;
               clear_cause();
               fipr(m,n);
          }
@@ -11996,7 +12029,7 @@
     void FLDI0(int n)
     {
          FR[n] = 0x00000000;
-         pc += 2;
+         PC += 2;
     }
 
 Possible Exceptions:
@@ -12014,9 +12047,9 @@
          1.0 Load
 
                                                                            Execution
-Format                  Summary of Operation        Instruction Code       States    T Bit
-FLDI1 FRn               0x3F800000 → FRn            1111nnnn10011101 1                 —
-—                       —                           —                      —           —
+PR      Format                  Summary of Operation        Instruction Code       States    T Bit
+0       FLDI1 FRn               0x3F800000 → FRn            1111nnnn10011101 1                 —
+1       —                       —                           —                      —           —
 
 
 Description
@@ -12028,7 +12061,7 @@
   void FLDI1(int n)
   {
          FR[n] = 0x3F800000;
-         pc += 2;
+         PC += 2;
   }
 
 Possible Exceptions:
@@ -12057,10 +12090,10 @@
 
 Operation
 
-  void FLDS(int m, float *FPUL)
+  void FLDS(int m/*, float *FPUL*/)
   {
-         *FPUL = FR[m];
-         pc += 2;
+         FPUL = FR[m];
+         PC += 2;
   }
 
 Possible Exceptions:
@@ -12112,9 +12145,9 @@
         double d;
         int l[2];
   }     tmp;
-        pc += 2;
+        PC += 2;
         clear_cause();
-        if(FPSCR.PR==0){
+        if(FPSCR_PR==0){
               FR[n] = *FPUL; /* convert from integer to float */
               tmp.d = *FPUL;
               if(tmp.l[1] & 0x1fffffff) inexact();
@@ -12157,9 +12190,43 @@
 
 Operation
 
-    void FMAC(int m,n)
+void normal_fmac(int m, int n)
+{
+union {
+      /*int*/ double x;
+      int l[4];
+}     dstx,tmpx;
+float dstf,srcf;
+      if((data_type_of(n) == PZERO)|| (data_type_of(n) == NZERO))
+               srcf = 0.0; /* flush denormalized value */
+      else      srcf = FR[n];
+      tmpx.x = FR[0]; /* convert single to int double */
+      tmpx.x *= FR[m]; /* exact product */
+      dstx.x = tmpx.x + srcf;
+      if(((dstx.x == srcf) && (tmpx.x != 0.0)) ||
+          ((dstx.x == tmpx.x) && (srcf != 0.0))) {
+          set_I();
+          if(sign_of(0)^ sign_of(m)^ sign_of(n))           {
+               dstx.l[3] -= 1; /* correct result */
+                   if(dstx.l[3] == 0xffffffff) dstx.l[2] -= 1;
+                   if(dstx.l[2] == 0xffffffff) dstx.l[1] -= 1;
+                   if(dstx.l[1] == 0xffffffff) dstx.l[0] -= 1;
+              }
+              else     dstx.l[3] |= 1;
+          }
+          if((dstx.l[1] & 0x01ffffff) || dstx.l[2] || dstx.l[3]) set_I();
+          if(FPSCR_RM == 1) {
+                   dstx.l[1] &= 0xfe000000; /* round toward zero */
+                   dstx.l[2]     = 0x00000000;
+                   dstx.l[3]     = 0x00000000;
+          }
+          dstf = dstx.x;
+          check_single_exception(&FR[n],dstf);
+  }
+
+    void FMAC(int m, int n)
     {
-            pc += 2;
+            PC += 2;
             clear_cause();
             if(FPSCR_PR == 1) undefined_operation();
             else if((data_type_of(0) == sNaN) ||
@@ -12169,7 +12236,7 @@
                      (data_type_of(m) == qNaN)) qnan(n);
             else if((data_type_of(0) == DENORM) ||
                      (data_type_of(m) == DENORM)) set_E();
-            else switch (data_type_of(0){
+            else switch (data_type_of(0)){
                 case NORM: switch (data_type_of(m)){
                 case PZERO:
 
@@ -12202,7 +12269,7 @@
               case PZERO:
               case NZERO:
               case NORM:       normal_fmac(m,n);       break;
-        }         break;
+        }         break; }
         case PZERO:
         case NZERO: switch (data_type_of(m)){
               case PINF:
@@ -12230,52 +12297,16 @@
           default: switch (data_type_of(n)){
           case DENORM: set_E();        break;
           case qNaN:        qnan(n);    break;
-               default:      inf(n,sign_of(0)^sign_of(m)^sign_of(n));break
+               default:      inf(n,sign_of(0)^sign_of(m)^sign_of(n));break;
                }       break;
           }        break;
      }
 }
-void normal_fmac(int m,n)
-{
-union {
-      int double x;
-      int l[4];
-}     dstx,tmpx;
-float dstf,srcf;
-      if((data_type_of(n) == PZERO)|| (data_type_of(n) == NZERO))
-               srcf = 0.0; /* flush denormalized value */
-      else      srcf = FR[n];
-      tmpx.x = FR[0]; /* convert single to int double */
-      tmpx.x *= FR[m]; /* exact product */
-      dstx.x = tmpx.x + srcf;
-      if(((dstx.x == srcf) && (tmpx.x != 0.0)) ||
-          ((dstx.x == tmpx.x) && (srcf != 0.0))) {
-          set_I();
-          if(sign_of(0)^ sign_of(m)^ sign_of(n))           {
-               dstx.l[3] -= 1; /* correct result */
 
                                                  Rev. 6.00 Sep 13, 2006 page 279 of 424
                                                                       REJ09B0318-0600
 Section 9 Instruction Descriptions
 
-                   if(dstx.l[3] == 0xffffffff) dstx.l[2] -= 1;
-                   if(dstx.l[2] == 0xffffffff) dstx.l[1] -= 1;
-                   if(dstx.l[1] == 0xffffffff) dstx.l[0] -= 1;
-              }
-              else     dstx.l[3] |= 1;
-          }
-          if((dstx.l[1] & 0x01ffffff) || dstx.l[2] || dstx.l[3]) set_I();
-          if(FPSCR_RM == 1) {
-                   dstx.l[1] &= 0xfe000000; /* round toward zero */
-                   dstx.l[2]     = 0x00000000;
-                   dstx.l[3]     = 0x00000000;
-          }
-          dstf = dstx.x;
-          check_single_exception(&FR[n],dstf);
-  }
-
-
-
 
 Rev. 6.00 Sep 13, 2006 page 280 of 424
 REJ09B0318-0600
@@ -12392,30 +12423,30 @@
 
 Operation
 
-  void FMOV(int m,n)                             /* FMOV FRm,FRn */
+  void FMOV(int m, int n)                             /* FMOV FRm,FRn */
   {
         FR[n] = FR[m];
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_DR(int m,n)                      /* FMOV DRm,DRn */
+  void FMOV_DR(int m, int n)                      /* FMOV DRm,DRn */
   {
         DR[n>>1] = DR[m>>1];
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_STORE(int m,n)                 /* FMOV.S FRm,@Rn */
+  void FMOV_STORE(int m, int n)                 /* FMOV.S FRm,@Rn */
   {
         store_int(FR[m],R[n]);
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_STORE_DR(int m,n)             /* FMOV DRm,@Rn */
+  void FMOV_STORE_DR(int m, int n)             /* FMOV DRm,@Rn */
   {
         store_quad(DR[m>>1],R[n]);
-        pc += 2;
+        PC += 2;
   }
-   void FMOV_LOAD(int m,n)                 /* FMOV.S @Rm,FRn */
+   void FMOV_LOAD(int m, int n)                 /* FMOV.S @Rm,FRn */
   {
         load_int(R[m],FR[n]);
-        pc += 2;
+        PC += 2;
   }
 
 
@@ -12423,41 +12454,41 @@
 REJ09B0318-0600
                                                 Section 9 Instruction Descriptions
 
-void FMOV_LOAD_DR(int m,n)      /* FMOV @Rm,DRn */
+void FMOV_LOAD_DR(int m, int n)      /* FMOV @Rm,DRn */
 {
      load_quad(R[m],DR[n>>1]);
-     pc += 2;
+     PC += 2;
 }
-void FMOV_RESTORE(int m,n)       /* FMOV.S @Rm+,FRn */
+void FMOV_RESTORE(int m, int n)       /* FMOV.S @Rm+,FRn */
 {
      load_int(R[m],FR[n]);
      R[m] += 4;
-     pc += 2;
+     PC += 2;
 }
-void FMOV_RESTORE_DR(int m,n) /* FMOV @Rm+,DRn */
+void FMOV_RESTORE_DR(int m, int n) /* FMOV @Rm+,DRn */
 {
      load_quad(R[m],DR[n>>1]) ;
      R[m] += 8;
-     pc += 2;
+     PC += 2;
 }
-void FMOV_SAVE(int m,n)          /* FMOV.S FRm,@–Rn */
+void FMOV_SAVE(int m, int n)          /* FMOV.S FRm,@–Rn */
 {
      store_int(FR[m],R[n]-4);
      R[n] -= 4;
-     pc += 2;
+     PC += 2;
 }
-void FMOV_SAVE_DR(int m,n)      /* FMOV DRm,@–Rn */
+void FMOV_SAVE_DR(int m, int n)      /* FMOV DRm,@–Rn */
 {
      store_quad(DR[m>>1],R[n]-8);
      R[n] -= 8;
-     pc += 2;
+     PC += 2;
 }
-void FMOV_INDEX_LOAD(int m,n)    /* FMOV.S @(R0,Rm),FRn */
+void FMOV_INDEX_LOAD(int m, int n)    /* FMOV.S @(R0,Rm),FRn */
 {
      load_int(R[0] + R[m],FR[n]);
-     pc += 2;
+     PC += 2;
 }
-void FMOV_INDEX_LOAD_DR(int m,n) /*FMOV @(R0,Rm),DRn */
+void FMOV_INDEX_LOAD_DR(int m, int n) /*FMOV @(R0,Rm),DRn */
 
                                           Rev. 6.00 Sep 13, 2006 page 285 of 424
                                                                REJ09B0318-0600
@@ -12465,17 +12496,17 @@
 
   {
         load_quad(R[0] + R[m],DR[n>>1]);
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_INDEX_STORE(int m,n)         /*FMOV.S FRm,@(R0,Rn)*/
+  void FMOV_INDEX_STORE(int m, int n)         /*FMOV.S FRm,@(R0,Rn)*/
   {
         store_int(FR[m], R[0] + R[n]);
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_INDEX_STORE_DR(int m,n)/*FMOV DRm,@(R0,Rn)*/
+  void FMOV_INDEX_STORE_DR(int m, int n)/*FMOV DRm,@(R0,Rn)*/
   {
         store_quad(DR[m>>1], R[0] + R[n]);
-        pc += 2;
+        PC += 2;
   }
 
 Possible Exceptions:
@@ -12533,56 +12564,56 @@
 
 Operation
 
-  void FMOV_STORE_XD(int m,n)             /* FMOV XDm,@Rn */
+  void FMOV_STORE_XD(int m, int n)             /* FMOV XDm,@Rn */
   {
         store_quad(XD[m>>1],R[n]);
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_LOAD_XD(int m,n)             /* FMOV @Rm,XDn */
+  void FMOV_LOAD_XD(int m, int n)             /* FMOV @Rm,XDn */
   {
       load_quad(R[m],XD[n>>1]);
-      pc += 2;
+      PC += 2;
   }
-  void FMOV_RESTORE_XD(int m,n)          /* FMOV @Rm+,DBn */
+  void FMOV_RESTORE_XD(int m, int n)          /* FMOV @Rm+,DBn */
   {
       load_quad(R[m],XD[n>>1]);
       R[m] += 8;
-      pc += 2;
+      PC += 2;
   }
-  void FMOV_SAVE_XD(int m,n)             /* FMOV XDm,@–Rn */
+  void FMOV_SAVE_XD(int m, int n)             /* FMOV XDm,@–Rn */
   {
       store_quad(XD[m>>1],R[n]-8);
       R[n] -= 8;
-      pc += 2;
+      PC += 2;
   }
-  void FMOV_INDEX_LOAD_XD(int m,n)             /* FMOV @(R0,Rm),XDn */
+  void FMOV_INDEX_LOAD_XD(int m, int n)             /* FMOV @(R0,Rm),XDn */
   {
       load_quad(R[0] + R[m],XD[n>>1]);
-      pc += 2;
+      PC += 2;
   }
-  void FMOV_INDEX_STORE_XD(int m,n)            /* FMOV XDm,@(R0,Rn) */
+  void FMOV_INDEX_STORE_XD(int m, int n)            /* FMOV XDm,@(R0,Rn) */
   {
         store_quad(XD[m>>1], R[0] + R[n]);
-        pc += 2;
+        PC += 2;
   }
-   void FMOV_XDXD(int m,n)               /* FMOV XDm,XDn */
+   void FMOV_XDXD(int m, int n)               /* FMOV XDm,XDn */
   {
 Rev. 6.00 Sep 13, 2006 page 288 of 424
 REJ09B0318-0600
                                                        Section 9 Instruction Descriptions
 
         XD[n>>1] = XD[m>>1];
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_XDDR(int m,n)         /* FMOV XDm,DRn */
+  void FMOV_XDDR(int m, int n)         /* FMOV XDm,DRn */
   {
         DR[n>>1] = XD[m>>1];
-        pc += 2;
+        PC += 2;
   }
-  void FMOV_DRXD(int m,n)         /* FMOV DRm,XDn */
+  void FMOV_DRXD(int m, int n)         /* FMOV DRm,XDn */
   {
         XD[n>>1] = DR[m>>1];
-        pc += 2;
+        PC += 2;
   }
 
 Possible Exceptions:
@@ -12623,9 +12654,9 @@
 
 Operation
 
-    void FMUL(int m,n)
+    void FMUL(int m, int n)
     {
-          pc += 2;
+          PC += 2;
                  clear_cause();
                  if((data_type_of(m) == sNaN) ||
                      (data_type_of(n) == sNaN)) invalid(n);
@@ -12633,7 +12664,7 @@
                            (data_type_of(n) == qNaN)) qnan(n);
                  else if((data_type_of(m) == DENORM) ||
                            (data_type_of(n) == DENORM)) set_E();
-                 else switch (data_type_of(m){
+                 else switch (data_type_of(m)){
                      case NORM: switch (data_type_of(n)){
                            case PZERO:
                            case NZERO: zero(n,sign_of(m)^sign_of(n));               break;
@@ -12657,7 +12688,7 @@
                 case NINF : switch (data_type_of(n)){
                       case PZERO:
                       case NZERO: invalid(n);         break;
-                      default:           inf(n,sign_of(m)^sign_of(n));break
+                      default:           inf(n,sign_of(m)^sign_of(n));break;
            }          break;
            }
   }
@@ -12718,7 +12749,7 @@
 
     void FNEG (int n){
            FR[n] = -FR[n];
-           pc += 2;
+           PC += 2;
     }
 
 
@@ -12838,28 +12869,13 @@
 
 Operation
 
-    void FSQRT(int n){
-         pc += 2;
-         clear_cause();
-         switch(data_type_of(n)){
-              case NORM      :     if(sign_of(n) == 0) normal_ fsqrt(n);
-                            else        invalid(n); break;
-              case DENORM:         if(sign_of(n) == 0) set_E();
-                            else        invalid(n); break;
-              case PZERO :
-              case NZERO :
-              case PINF      :       break;
-              case NINF      :       invalid(n); break;
-              case qNaN      :       qnan(n);       break;
-              case sNaN      :       invalid(n); break;
 
 
 Rev. 6.00 Sep 13, 2006 page 296 of 424
 REJ09B0318-0600
                                                 Section 9 Instruction Descriptions
 
-     }
-}
+
 void normal_fsqrt(int n)
 {
 union {
@@ -12871,7 +12887,7 @@
       int l[2];
 }     dstd,tmpd;
 union {
-      int double x;
+      /*int*/ double x;
       int l[4];
 }     tmpx;
       if(FPSCR_PR == 0) {
@@ -12904,6 +12920,22 @@
             }
   }
 
+    void FSQRT(int n){
+         PC += 2;
+         clear_cause();
+         switch(data_type_of(n)){
+              case NORM      :     if(sign_of(n) == 0) normal_fsqrt(n);
+                            else        invalid(n); break;
+              case DENORM:         if(sign_of(n) == 0) set_E();
+                            else        invalid(n); break;
+              case PZERO :
+              case NZERO :
+              case PINF      :       break;
+              case NINF      :       invalid(n); break;
+              case qNaN      :       qnan(n);       break;
+              case sNaN      :       invalid(n); break;
+     }
+}
 FSQRT Special Cases
 
       FRn           +NORM    –NORM         +0        –0     +INF     –INF     qNaN     sNaN
@@ -12939,10 +12971,10 @@
 
 Operation
 
-  void FSTS(int n, float *FPUL)
+  void FSTS(int n/*, float *FPUL*/)
   {
-         FR[n] = *FPUL;
-         pc += 2;
+         FR[n] = FPUL;
+         PC += 2;
   }
 
 Possible Exceptions:
@@ -12981,9 +13013,9 @@
 
 Operation
 
-    void FSUB (int m,n)
+    void FSUB_ (int m, int n) /* FSUB is a "#define" symbol, so we have to rename the name of this function */
     {
-         pc += 2;
+         PC += 2;
          clear_cause();
          if((data_type_of(m) == sNaN) ||
               (data_type_of(n) == sNaN)) invalid(n);
@@ -12993,7 +13025,7 @@
                    (data_type_of(n) == DENORM)) set_E();
          else switch (data_type_of(m)){
               case NORM: switch (data_type_of(n)){
-                   case NORM:        normal_faddsub(m,n,SUB); break;
+                   case NORM:        normal_faddsub(m,n,FSUB); break;
 
 
 Rev. 6.00 Sep 13, 2006 page 300 of 424
@@ -13080,46 +13112,18 @@
 
     #define N_INT_SINGLE_RANGE 0xcf000000 & 0x7fffffff              /* -1.000000 * 2^31 */
     #define P_INT_SINGLE_RANGE 0x4effffff           /* 1.fffffe * 2^30 */
-    #define N_INT_DOUBLE_RANGE 0xc1e0000000200000 & 0x7fffffffffffffff
-    #define P_INT_DOUBLE_RANGE 0x41e0000000000000
-
-
-    void FTRC(int m, int *FPUL)
-    {
-         pc += 2;
-         clear_cause();
-         if(FPSCR.PR==0){
-                 case(ftrc_single_ type_of(m)){
-                 NORM:      *FPUL = FR[m];         break;
-                 PINF:      ftrc_invalid(0);       break;
-                 NINF:      ftrc_invalid(1);       break;
-                 }
-         }
+    #define N_INT_DOUBLE_RANGE int64_of_string("0xc1e0000000200000") & int64_of_string("0x7fffffffffffffff")
+    #define P_INT_DOUBLE_RANGE int64_of_string("0x41e0000000000000")
 
-                                                      Rev. 6.00 Sep 13, 2006 page 303 of 424
-                                                                           REJ09B0318-0600
-Section 9 Instruction Descriptions
 
-        else{                        /* case FPSCR.PR=1 */
-               case(ftrc_double_type_of(m)){
-               NORM:        *FPUL = DR[m>>1]; break;
-               PINF:        ftrc_invalid(0);    break;
-               NINF:        ftrc_invalid(1);    break;
-               }
-        }
-  }
-  int ftrc_signle_type_of(int m)
+  void ftrc_invalid(int sign, int *FPUL)
   {
-        if(sign_of(m) == 0){
-              if(FR_HEX[m] > 0x7f800000)         return(NINF);    /* NaN */
-              else if(FR_HEX[m] > P_INT_SINGLE_RANGE)
-                            return(PINF);      /* out of range,+INF */
-              else          return(NORM);      /* +0,+NORM            */
-        } else {
-              if((FR_HEX[m] & 0x7fffffff) > N_INT_SINGLE_RANGE)
-                            return(NINF);   /* out of range ,+INF,NaN*/
-              else          return(NORM);    /* -0,-NORM                   */
+        set_V();
+         if((FPSCR & ENABLE_V) == 0){
+                 if(sign == 0)             *FPUL = 0x7fffffff;
+                 else                      *FPUL = 0x80000000;
         }
+        else fpu_exception_trap();
   }
   int ftrc_double_type_of(int m)
   {
@@ -13131,25 +13135,53 @@
                             return(PINF);      /* out of range,+INF */
               else          return(NORM);      /* +0,+NORM            */
         } else {
-              if((DR_HEX[m>>1] & 0x7fffffffffffffff) >= N_INT_DOUBLE_RANGE)
+              if((DR_HEX[m>>1] & int64_of_string("0x7fffffffffffffff")) >= N_INT_DOUBLE_RANGE)
                             return(NINF);      /* out of range ,+INF,NaN*/
               else          return(NORM);      /* -0,-NORM                  */
         }
+  }
+  int ftrc_single_type_of(int m)
+  {
+        if(sign_of(m) == 0){
+              if(FR_HEX[m] > 0x7f800000)         return(NINF);    /* NaN */
+              else if(FR_HEX[m] > P_INT_SINGLE_RANGE)
+                            return(PINF);      /* out of range,+INF */
+              else          return(NORM);      /* +0,+NORM            */
+        } else {
+              if((FR_HEX[m] & 0x7fffffff) > N_INT_SINGLE_RANGE)
+                            return(NINF);   /* out of range ,+INF,NaN*/
+              else          return(NORM);    /* -0,-NORM                   */
+        }
+  }
+    void FTRC(int m, int *FPUL)
+    {
+         PC += 2;
+         clear_cause();
+         if(FPSCR_PR==0){
+                 switch(ftrc_single_type_of(m)){
+                 case NORM:      *FPUL = FR[m];         break;
+                 case PINF:      ftrc_invalid(0, FPUL);       break;
+                 case NINF:      ftrc_invalid(1, FPUL);       break;
+                 }
+         }
+
+                                                      Rev. 6.00 Sep 13, 2006 page 303 of 424
+                                                                           REJ09B0318-0600
+Section 9 Instruction Descriptions
+
+        else{                        /* case FPSCR.PR=1 */
+               switch(ftrc_double_type_of(m)){
+               case NORM:        *FPUL = DR[m>>1]; break;
+               case PINF:        ftrc_invalid(0, FPUL);    break;
+               case NINF:        ftrc_invalid(1, FPUL);    break;
+               }
+        }
+  }
 
 Rev. 6.00 Sep 13, 2006 page 304 of 424
 REJ09B0318-0600
                                                                 Section 9 Instruction Descriptions
 
-  }
-  void ftrc_invalid(int sign, int *FPUL)
-  {
-        set_V();
-         if((FPSCR & ENABLE_V) == 0){
-                 if(sign == 0)             *FPUL = 0x7fffffff;
-                 else                      *FPUL = 0x80000000;
-        }
-        else fpu_exception_trap();
-  }
 
 FTRC Special Cases
 
@@ -13235,7 +13267,7 @@
   {
   float saved_vec[4],result_vec[4];
   int saved_fpscr;
-  int dst,i;
+  int dst,i,j;
            if(FPSCR_PR == 0) {
                  PC += 2;
                  clear_cause();
@@ -13244,7 +13276,7 @@
                  dst = 12 - n;                    /* select other vector than FVn */
                  for(i=0;i<4;i++)saved_vec [i] = FR[dst+i];
                  for(i=0;i<4;i++){
-                       for(j=0;j<4;j++) FR[dst+j] = XF[i+4j];
+                       for(j=0;j<4;j++) FR[dst+j] = XF[i+4*j];
                        fipr(n,dst);
                        saved_fpscr |= FPSCR & (CAUSE|FLAG) ;
                        result_vec [i] = FR[dst+3];
@@ -13468,7 +13500,7 @@
 
         LDCSSR(int m)             /* LDC Rm,SSR : Privileged */
         {
-            SSR=R[m],
+            SSR=R[m];
             PC+=2;
                                                         Rev. 6.00 Sep 13, 2006 page 313 of 424
                                                                              REJ09B0318-0600
@@ -13552,7 +13584,7 @@
 }
 
 
-LDCMRn_BANK(Long m) /* LDC.L @Rm+,Rn_BANK : Privileged */
+LDCMRn_BANK(long m) /* LDC.L @Rm+,Rn_BANK : Privileged */
                   /* n=0–7 */
 {
     Rn_BANK=Read_Long(R[m]);
@@ -13600,14 +13632,14 @@
   #define FPSCR_MASK 0x003FFFFF
 
 
-  LDSFPUL(int m, int *FPUL)                 /* LDS Rm,FPUL        */
+  LDSFPUL(int m/*, int *FPUL*/)                 /* LDS Rm,FPUL        */
   {
-         *FPUL=R[m];
+         FPUL=R[m];
          PC+=2;
   }
-  LDSMFPUL(int m, int *FPUL)                 /* LDS.L @Rm+,FPUL        */
+  LDSMFPUL(int m/*, int *FPUL*/)                 /* LDS.L @Rm+,FPUL        */
   {
-         *FPUL=Read_Long(R[m]);
+         FPUL=Read_Long(R[m]);
          R[m]+=4;
          PC+=2;
   }
@@ -13759,19 +13791,19 @@
 
   LDTLB( )       /*LDTLB */
   {
-        TLB[MMUCR. URC] .ASID=PTEH & 0x000000FF;
-        TLB[MMUCR. URC] .VPN=(PTEH & 0xFFFFFC00)>>10;
-        TLB[MMUCR. URC] .PPN=(PTEH & 0x1FFFFC00)>>10;
-        TLB[MMUCR. URC] .SZ=(PTEL & 0x00000080)>>6 |
+        TLB_MMUCR_URC.ASID=PTEH & 0x000000FF;
+        TLB_MMUCR_URC.VPN=(PTEH & 0xFFFFFC00)>>10;
+        TLB_MMUCR_URC.PPN=(PTEH & 0x1FFFFC00)>>10;
+        TLB_MMUCR_URC.SZ=(PTEL & 0x00000080)>>6 |
             (PTEL & 0x00000010)>>4;
-        TLB[MMUCR. URC] .SH=(PTEH & 0x00000002)>>1;
-        TLB[MMUCR. URC] .PR=(PTEH & 0x00000060)>>5;
-        TLB[MMUCR. URC] .WT=(PTEH & 0x00000001);
-        TLB[MMUCR. URC] .C=(PTEH & 0x00000008)>>3;
-        TLB[MMUCR. URC] .D=(PTEH & 0x00000004)>>2;
-        TLB[MMUCR. URC] .V=(PTEH & 0x00000100)>>8;
-        TLB[MMUCR. URC] .SA=(PTEA & 0x00000007);
-        TLB[MMUCR. URC] .TC=(PTEA & 0x00000008)>>3;
+        TLB_MMUCR_URC.SH=(PTEH & 0x00000002)>>1;
+        TLB_MMUCR_URC.PR=(PTEH & 0x00000060)>>5;
+        TLB_MMUCR_URC.WT=(PTEH & 0x00000001);
+        TLB_MMUCR_URC.C=(PTEH & 0x00000008)>>3;
+        TLB_MMUCR_URC.D=(PTEH & 0x00000004)>>2;
+        TLB_MMUCR_URC.V=(PTEH & 0x00000100)>>8;
+        TLB_MMUCR_URC.SA=(PTEA & 0x00000007);
+        TLB_MMUCR_URC.TC=(PTEA & 0x00000008)>>3;
 
 
         PC+=2;
@@ -13819,7 +13851,7 @@
 
 Operation
 
-  MACL(long m, long n)            /* MAC.L @Rm+,@Rn+ */
+  MACL_(long m, long n)            /* MAC.L @Rm+,@Rn+ */ /* MACL is defined, so we have to rename the name of this function */
   {
         unsigned long RnL,RnH,RmL,RmH,Res0,Res1,Res2;
         unsigned long temp0,temp1,temp2,temp3;
@@ -13873,11 +13905,11 @@
 
 
   if(fnLmL<0){
-              ~
-       Res2= Res2;
+              
+       Res2=!Res2;
        if (Res0==0) Res2++;
-                     ~
-       else Res0=( Res0)+1;
+                     
+       else Res0=(!Res0)+1;
   }
   if(S==1){
        Res0=MACL+Res0;
@@ -13887,7 +13919,7 @@
                                                 Section 9 Instruction Descriptions
 
     if (MACL>Res0) Res2++;
-    if (MACH&0x00008000);
+    if (bool_of_word(MACH&0x00008000));
     else Res2+=MACH|0xFFFF0000;
            Res2+=MACH&0x00007FFF;
 
@@ -14152,7 +14184,7 @@
 
 
   MOVLL(long m, long n) /* MOV.L @Rm,Rn */
-  }
+  {
         R[n]=Read_Long(R[m]);
         PC+=2;
   }
@@ -14343,7 +14375,7 @@
  }
 
 
- MOVWI(d, n) /* MOV.W @(disp,PC),Rn */
+ MOVWI(int d, int n) /* MOV.W @(disp,PC),Rn */
  {
         unsigned int disp;
 
@@ -14576,7 +14608,7 @@
 
 Operation
 
- MOVBS4(long d, long n    /* MOV.B R0,@(disp,Rn) */
+ MOVBS4(long d, long n)    /* MOV.B R0,@(disp,Rn) */
  {
        long disp;
        disp=(0x0000000F & (long)d);
@@ -14730,9 +14762,7 @@
 
   MOVCAL(int n)             /*MOVCA.L      R0,@Rn */
          {
-             if ((is_write_back_memory(R[n]))
-                  && (look_up_in_operand_cache(R[n]) == MISS))
-                               allocate_operand_cache_block(R[n]);
+             if_is_write_back_memory_and_look_up_in_operand_cache_eq_miss_then_allocate_operand_cache_block(R[n]);
              Write_Long(R[n], R[0]);
              PC+=2;
          }
@@ -14877,7 +14907,7 @@
 
   MULU(long m, long n) /* MULU Rm,Rn                 */
   {
-         MACL=((unsigned long)(unsigned short)R[n]*
+         MACL=(unsigned long)(unsigned short)R[n]*
          (unsigned long)(unsigned short)R[m];
           PC+=2;
   }
@@ -15021,7 +15051,7 @@
 
   NOT(long m, long n) /* NOT Rm,Rn */
   {
-              R[n]=∼R[m];
+              R[n]=!R[m];
               PC+=2;
   }
 
@@ -15099,7 +15129,7 @@
 
   OCBP(int n)               /* OCBP @Rn */
   {
-      if(is_dirty_block(R[n]))          write_back(R[n])
+      if_is_dirty_block_then_write_back(R[n]);
       invalidate_operand_cache_block(R[n]);
       PC+=2;
   }
@@ -15140,7 +15170,7 @@
 
   OCBWB(int n)               /* OCBWB @Rn */
          {
-             if(is_dirty_block(R[n]))           write_back(R[n]);
+             if_is_dirty_block_then_write_back(R[n]);
              PC+=2;
          }
 
@@ -15700,7 +15730,7 @@
 
 Operation
 
-  SHAD(int m,n) /*SHAD Rm,Rn */
+  SHAD(int m, int n) /*SHAD Rm,Rn */
   {
              int sgn=R[m] & 0x80000000;
              if (sgn==0)
@@ -15712,7 +15742,7 @@
                                  R[n] = 0xFFFFFFFF;
             }
             else
-                     R[n]=(long)R[n] >> ((~R[m] & 0x1F)+1);
+                     R[n]=(long)R[n] >> ((!R[m] & 0x1F)+1);
             PC+=2;
   }
 
@@ -15866,7 +15896,7 @@
 
 Operation
 
-  SHLD(int m,n)/*SHLD Rm,Rn */
+  SHLD(int m, int n)/*SHLD Rm,Rn */
   {
          int sgn = R[m] & 0x80000000;
          if (sgn == 0)
@@ -15874,7 +15904,7 @@
          else if ((R[m] & 0x1F) == 0)
                      R[n] = 0;
          else
-                     R[n]=(unsigned)R[n] >> ((~R[m] & 0x1F)+1);
+                     R[n]=(unsigned)R[n] >> ((!R[m] & 0x1F)+1);
          PC+=2;
   }
 
@@ -16310,7 +16340,7 @@
 
   STCMSR(int n)          /* STC.L SR,@-Rn : Privileged */
         {
-              R[n]–=4;
+              R[n]-=4;
               Write_Long(R[n],SR);
               PC+=2;
         }
@@ -16323,7 +16353,7 @@
                                                Section 9 Instruction Descriptions
 
      {
-         R[n]–=4;
+         R[n]-=4;
          Write_Long(R[n],GBR);
          PC+=2;
      }
@@ -16331,7 +16361,7 @@
 
 STCMVBR(int n)      /* STC.L VBR,@-Rn : Privileged */
      {
-         R[n]–=4;
+         R[n]-=4;
          Write_Long(R[n],VBR);
          PC+=2;
      }
@@ -16339,7 +16369,7 @@
 
 STCMSSR(int n)      /* STC.L SSR,@-Rn : Privileged */
      {
-         R[n]–=4;
+         R[n]-=4;
          Write_Long(R[n],SSR);
          PC+=2;
      }
@@ -16347,7 +16377,7 @@
 
 STCMSPC(int n)      /* STC.L SPC,@-Rn : Privileged */
      {
-         R[n]–=4;
+         R[n]-=4;
          Write_Long(R[n],SPC);
          PC+=2;
      }
@@ -16355,7 +16385,7 @@
 
 STCMSGR(int n)      /* STC.L SGR,@-Rn : Privileged */
      {
-         R[n]–=4;
+         R[n]-=4;
          Write_Long(R[n],SGR);
          PC+=2;
      }
@@ -16368,7 +16398,7 @@
 Section 9 Instruction Descriptions
 
         {
-              R[n]–=4;
+              R[n]-=4;
               Write_Long(R[n],DBR);
               PC+=2;
         }
@@ -16377,7 +16407,7 @@
   STCMRm_BANK(int n)             /* STC.L Rm_BANK,@-Rn : Privileged */
                                  /* m=0–7 */
         {
-              R[n]–=4;
+              R[n]-=4;
               Write_Long(R[n],Rm_BANK);
               PC+=2;
         }
@@ -16444,7 +16474,7 @@
 
   STSMMACH(int n)           /* STS.L MACH,@-Rn */
   {
-      R[n]–=4;
+      R[n]-=4;
       Write_Long(R[n],MACH);
       PC+=2;
   }
@@ -16452,7 +16482,7 @@
 
   STSMMACL(int n)           /* STS.L MACL,@-Rn */
   {
-      R[n]–=4;
+      R[n]-=4;
       Write_Long(R[n],MACL);
       PC+=2;
   }
@@ -16460,7 +16490,7 @@
 
   STSMPR(int n)          /* STS.L PR,@-Rn */
   {
-      R[n]–=4;
+      R[n]-=4;
       Write_Long(R[n],PR);
       PC+=2;
   }
@@ -16510,18 +16540,18 @@
 
 Operation
 
-  STS(int n, int *FPUL)                     /* STS FPUL,Rn   */
+  STS(int n/*, int *FPUL*/)                     /* STS FPUL,Rn   */
   {
-        R[n]= *FPUL;
+        R[n]= FPUL;
         PC+=2;
   }
-  STS_SAVE(int n, int *FPUL)             /* STS.L FPUL,@-Rn       */
+  STS_SAVE(int n/*, int *FPUL*/)             /* STS.L FPUL,@-Rn       */
   {
         R[n]-=4;
-        Write_Long(R[n],*FPUL) ;
+        Write_Long(R[n],FPUL) ;
         PC+=2;
   }
-  STS(int     n)             /* STS FPSCR,Rn      */
+  STS_(int     n)             /* STS FPSCR,Rn      */ /* STS is defined, name */
   {
         R[n]=FPSCR&0x003FFFFF;
         PC+=2;
@@ -16529,7 +16559,7 @@
   STS_RESTORE(int       n)   /* STS.L FPSCR,@-Rn       */
   {
         R[n]-=4;
-        Write_Long(R[n],FPSCR&0x003FFFFF)
+        Write_Long(R[n],FPSCR&0x003FFFFF);
         PC+=2;
   }
 
@@ -16894,12 +16924,12 @@
        TRA=imm<<2;
        SSR=SR;
        SPC=PC+2;
-       SGR=R15;
-       SR.MD=1;
-       SR.BL=1;
-       SR.RB=1;
+       SGR=R[15];
+       SR_MD=1;
+       SR_BL=1;
+       SR_RB=1;
        EXPEVT=0x00000160;
-       PC=VBR+H'00000100;
+       PC=VBR+H_00000100;
  }
 
 
@@ -17786,4 +17816,4 @@
 
 
 1753, Shimonumabe, Nakahara-ku, Kawasaki-shi, Kanagawa 211-8668 Japan   REJ09B0318-0600
-
\ Pas de fin de ligne à la fin du fichier.
+
