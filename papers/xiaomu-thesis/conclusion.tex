\chapter{Discussion and conclusion}
\label{cpt:concl}

% % JF->XM: general comment: self-defined ---> user-defined

We developed the certification of a part of
an ARM instruction set simulator called \simlight,
using
% the formal representation of the concrete C program
% according to
the operational semantics of the C language provided by the \compcert project.
Correctness proofs were performed under the interactive proof assistant
Coq.
A large part of the Coq specification and of the model of the simulator
were automatically produced from the pseudo-code available in the ARM reference manual.
A Coq proof technique for performing \emph{inversions} was introduced in
order to solve cumbersome proof steps in our work
in a better way than Coq built-in tactics.
Moreover, the size of proof terms generated by our our \hcinv
is much lower than with built-in Coq \inversion,
making Coq type checking and compilation more efficient.
Additionally, we have built a test generator for the ARM instruction decoder,
which generates massive tests covering all ARM instructions.

The following sections contains
an assessment on the usage of operational semantics
in proving the correctness of \simlight and the feasibility of
using this new approach for proving general C programs,
the overall development size of SimSoC-Cert and the TCB.
We conclude with prospects of future work.

\section{Using operational semantics for proving C programs}

The certification technique we applied for \simlight is based on the C operational
semantics provided by \compcert.
The Coq formal representation of the C programs of each ARM instruction
can be obtained from
the instruction pseudo-code intermediate representation AST in two ways:
either by translating it to \compcert C AST,
% JF: the important part of this pretty-printing is more the sharing of types,
% something that  you rightly don't want to explain here...
% moreover it is not part of the comparison since used in the 2 options
% -> let's just forget it
% and pretty-printing it in Coq,
or by translating it to a textual C program,
then parsing it to \compcert C AST using the \compcert C parser.
% and pretty-printing it in Coq.
%
In our experiments, no difference could be observed between the two approaches
-- no information was lost using \compcert C parser.
\compcert C supports a C subset which is rich enough to describe the
operations of ARM instructions.
% % JF -> XM: I see your point but you have to be more careful.
% % OK, we avoid unproved components as far a possible, and
% % the parser is not proved -- it is actually unclear how to get
% % a suitable specification.
% % That said, we are already confident that this parser is good.
% % Here we get additional evidence that this pareser can be trusted
% % but it is not a breakthrough.
% In the future, we can expect other C programs without their own intermediate
% representation AST to use the \compcert C parser directly.

Correctness proofs were performed using the Coq proof assistant.
In this approach to the certification of C programs,
the Coq proof steps in Coq are not simple.
However, we were actually able to consider C programs
having a large size and complex specification,
using the full expressive power of Coq.
%
% % JF: yes we could speak again about ax sem, but we have nothing
% %  more than claims staed inthe intro, since we did not (want to) try.
% than using axiomatic semantics.
%
Our work assesses the feasibility of using operational semantics for
certifying C programs.

Proof steps related to the \compcert C semantics can be simplified
a lot by defining Coq tactics with Ltac (the tactics language).
% % JF: we know we know...
% As an interactive proof assistant, the proof steps require the
% interaction with its user.
Our initial first proof script for ADC instruction contained thousands
of lines of code.  Then, we identified repetitive sequences and
started to define our own proof tactics in the Ltac language,
resulting into much shorter proof scripts.  The second version for ADC
correctness proof was approximately three times smaller than the
first one.
% Repetitive proof steps containing seqences of commands
% can be defined in one general Ltac definition.
In the design of these tactics, we did not seek for generality.
However, since ARM instructions within the same category often have
very similar statements and expressions, our tactics can actually be
reused.
% the user-defined tactics can be reused in all of them.

In Section~\ref{sec:tactic}, we have introduced more general tactics
implemented in SimSoC-Cert, like finding functions in the C memory
model, reusing load/store operations, etc.  Those tactics are not
specific to \simlight, they only deal with \compcert C semantics and
memory operations.  The same holds for our inversion technique: it was
implemented for the needs of SimSoC-Cert as a tactic \hcinv dedicated
to the inductive relations defined in \compcert (see
Section~\ref{ssec:invssc}).  However, these tactics can be reused in
other projects using the same approach to the correctness proof of
\compcert C programs, e.g. the CCCBIP project
which recently started in our group and aims at building a certifying compiler
from a high-level component-based language dedicated to embedded systems
(BIP), with \compcert C as its target. 


% To reason on the C operational
% semantics, \emph{inversions} of the evaluation rules are the essential steps.
% For other projects intend to use \compcert C operational semantics for
% C program certification, e.g. the CCCBIP project, it is possible to
% reuse the tactics defined in SimSoC-Cert.


\section{Hand-crafted inversion}
%%Copy from CPP12 need to be changed 

Our hand-crafted inversion presented in Chapter~\ref{cpt:inv}
was experimented on large proofs relying on big inductive relations
independently defined in the \compcert project.
It played a key role for the success of this approach to correctness proofs
of C programs, and
the extra flexibility provided by \hcinv inversions could be exploited to
produce smaller, more robust and manageable proofs.

It is not yet a fully automatic tactic, like the original \inversion. 
We think that
automation could be realized by interacting with the internals of Coq.
This would be done for efficiency concerns and would not harm
in the cases where the proof can be automatically completed,
or is followed by tactics which do not refer to names produced by inversion.

But in a project with a big size specification like \simsoccert,
where proofs require fine tuning,
interactions between the human and the proof assistant cannot be avoided.
In general, in such situations,
statements involve arbitrarily complex definitions,
so we cannot make the assumption that decision procedures can be used.
The issue is then to provide appropriate mechanisms,
so that writing proof scripts and interacting with the proof assistant
is made easy.
%
We think that our hand-crafted inversion technique is a good tool
in this respect:
it is flexible enough for the user,
practical situations can be managed
with a full control on the script and valuable improvements
of the script are easier to design.


Let us mention another possible application of the technique. Inversion is
sometimes needed to write a function whose properties will be established later
(as opposed to providing a monolithic and exhaustive Hoare-style specification
and along with a VC generator such as Program). In this context, simply using
the proof engine and the inversion tactic tends to generate unmanageably large
terms. We can expect our technique to be very helpful in such situations.

\section{Development size}
\begin{table}[ht]
  \centering
  \begin{tabular}{|l|r@{~}|}
    \hline
    Original ARM ref man (txt)           & 49655 \\
    ARM Parsing to an OCaml AST         & 1068 \\
    Generator (Simgen) for ARM         &   10675 \\
    Generator specifications for SH4      & 737 \\
    General C libraries on ARM         & 1852 \\
    General Coq libraries on ARM         & 1569 \\
    Generated C code for \simlight ARM operations   & 6681 \\
    Generated Coq code for ARM operations   & 2068 \\
    Generated Coq code for ARM decoding  & 592 \\
    Projection   & 857 \\
    Proof script for ADC (2011)    & 3171 \\
    Proof script for ADC (2012)    & 1204 \\
    Definition of \hcinv       &551\\
    Definition of other user-defined tactics      &185\\
%% Xiaomu: please complete
    Proof script for auxiliary functions   & 856 \\
    Proof script for BL (2012)   & 437 \\
    Proof script for LDRB (2012)   & 170 \\
    Proof script for MRS (2012)   & 322 \\
    \hline
  \end{tabular}
  \smallskip
  \caption{Sizes (in number of lines)}
  \label{tab:sizes}
\end{table}

Table~\ref{tab:sizes} shows the size of our development.
The size of the generator is almost the same as the total
number of lines of the generated part for ARMv6.
But note that this is the version redesigned by F. Tuong
in order to be more general,
so that it could be reused with other specific processors.
Currently, besides ARM, it is applied to the SH4 reference manual
where, instead of a specific pseudo-code,
instructions are described using a C syntax.
% There is a good hope that it could be used on other architectures
% \jf{Could be shortened because work by F Tuong.}
% According to different architecture, we will have different size of development.
% But thanks to the experiment of SH4, we are now certain that
% the framework is capable to be used for another processor
% architecture. The only requirement for the object processor is that
% its reference manual should be well structured and can be transformed
% to analyzable text. The most important thing is that it contains formal or
% semi-formal descriptions to be automatically translated to a specific
% intermediate representation.

One can note also that the generated code for the ISS
takes 50\:\% of the Coq formal model,
and almost 70\:\% of the C simulator.
Although the gain may be considered as not that large,
we think that it was worth taking this approach,
given the repetitive nature of instructions.
% Considering the development worthiness,
% the instruction set simulation should be complex enough;
% at least the generated code is more than the specification for such processor.
% As we mentioned in Section~\ref{ssc:arm}, the core of a processor
% simulator is ISS.

About the proof efforts,
the first experiment on the correctness of ADC
%(11 lines of pseudo-code)
costed one month.
The number of Coq lines for the proof script is quite large
(about 3200 for the first version),
especially if we compare with the 11 lines of the corresponding
pseudo-code in the reference manual.
% And the size of the experiment code is quite huge,
% with no optimization or user-defined tactics applied, 3171 loc.
At this stage, we did not develop user-defined tactics.
Now, using \hcinv and other user-defined tactics,
not only maintenability is much improved,
but the development time for a proof is much lower.
Less than one week is needed for an instruction as complicated as ADC.
% Compared to the size of the definition of \hcinv
% and other user-defined tactics,
% the number of lines of code
% of the new version of correctness proof script has been highly
% reduced. And using the new \hcinv with the experiment we obtained,
% the development time has been saved, too.
% To complete a correctness proof of an instruction,
% we need only less than a week,
% which is enough for a quite complicate instruction
% like ADC.
%
% % JF -> XM: you said 12 but I count 11 here!
% % Either the count is wrong, or you forgot an instruction
Until now, 11 instructions were proved correct,
one from each instruction category.
They are given in Table~\ref{tab:prvinst}.
% (the instruction we have proved
% in the category is inside the parenthesis) :
% branch ins truction (BL),
% data processing instruction (ADC),
% Multiply instruction (MUL),
% parallel arithmetic addition and subtraction instruction (QADD16),
% extended instruction (XTAB16),
% miscellaneous arithmetic instruction (CLZ),
% status register accessing instruction (MRS),
% load and store instruction (LDR),
% load and store multiple instruction (LDM),
% semaphore instruction (SWP),
% and exception generating instruction (BKPT).
\begin{table}[ht]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Category & Instruction name \\
    \hline
    branch & BL \\
    data processing & ADC \\
    multiply & MUL \\
    parallel arithmetic addition and subtraction & QADD16 \\
    extended instruction & UXTAB16 \\
    miscellaneous arithmetic & CLZ \\
    status register access & MRS \\
    load and store & LDR \\
    load and store multiple & LDM \\
    semaphore & SWP \\
    \hline
  \end{tabular}
  \smallskip
  \caption{ARM instructions having a correctness proof}
  \label{tab:prvinst}
\end{table}

\section{Trusted Code Base}

% The trust we may have in our result depends on the faithfulness of its
% statement with relation to the expected behavior of the simulation of
% \texttt{ADC} in \simlight.  It is mainly based on the manually written
% Coq and C library functions, the translators written in OCaml
% described in Section~\ref{sec:overall} (including the
% pretty-printer for Coq), the final phase of the Compcert compiler, and
% the formal definition of $\mathit{proc\_state\_related}$.

Our proofs depend on several tools developed elsewhere:
the Coq proof assistant,
the OCaml compiler and the \compcert C certified compiler.
The TCB of these external tools have to be considered independently.
Regarding Coq, the TCB is essentially its kernel.

Next, the TCB includes the formal version of the ARM reference manual
on which proofs are carried on:
hand-written and automatically produced Coq definitions,
as described in Figure~\ref{fig:arch}.
Alternatively,
automatically produced Coq definitions could be replaced by
the textual reference manual (patched by our bug fixes)
and Coq code generators.
% % JF: no, unless we consider simlight itself, and in that
% %  case we have to add gcc
% the \compcert C AST pretty-printer
% the hand-written Coq, %  and C library functions, %% NO they are proved
% the generated Coq and C representations,
The TCB also includes
the Coq projections from the \compcert C AST representation of \simlight code
to our abstract Coq model.
% Altogether, we have the TCB of
% the correctness statements for relating \simlight to the expected behavior
% as in the formal model.

% % JF -> XM What do you mean? Why the TCB should grow?
% % --> commented out unless something important has to be stated.
% In the future, the development size of correctness proofs will grow
% larger when all the work is done for 147 ARM instructions
% and all the auxiliary functions,
% approximately three times comparing to our TCB.


% \section{Validation}

% \jf{Optionally remove?}

% The validation of new ISS of ARMv6 integrated into SimSoC has been
% introduced in Section ~\ref{ssc:vali}. And a brief speaking on
% Evaluation of Coq specification has been mentioned there, too. In
% general, the C specification can be executed as fast as the older
% hand-written version of ARMv5, but we gain more confidence in the new
% version with the correctness proofs. Although the execution speed is
% very low, the extraction from formal model is still an executable
% and reliable model.

% Using a generator avoids many typo-like errors. However, other kinds
% of errors remain possible.
% Besides the bugs in the documentation which were reported before,
% there are the last bugs we found and fixed
% while trying to boot Linux on the SPEArPlus600 SoC simulator:
% \begin{itemize}
%  \item After the execution of an {\stt LDRBT instruction}, the content
%    of the base register ({\stt Rn}) was wrong. It was due to a bug in
%    the reference manual itself; the last line of the pseudo-code has
%    to be deleted\footnote{This error is fixed in the ARMv7 reference
%      manual, which is now the recommended manual for the ARMv6
%      architecture.}.
%  \item
%    Base register is where the base address stored.  The address may be
%    changed by load/store instructions write-back.  In the operation of
%    such instruction, the write-back to base register should ahead of the
%    certain memory access.  If the memory access fails, the base
%    register then must keep the original value. Such rule is only
%    explained informally.  Our generated ISS manages {\em data aborts}
%    using C++ exception mechanism. As a consequence, moving the
%    statement doing the write-back at the end of the instruction code
%    (and so after any possible {\stt throw}) is sufficient to keep the
%    base register unchanged in case of exception.
%    Some load/store in structure can modify the processor mode; in this
%    case the meaning of base register may be changed. Then write-back
%    must affect a banked version of it instead of current version.
%  \item Additionally, there is a half-word access to an odd address
%    while executing SPEArPlus600 specific code. In this case, the
%    manual indicates that the result is ``unpredictable''. % ...
%  \end{itemize}

\section{Future work}

% % JF -> XM, [GC] general comment:
% % I removed parts wich could be considered as weak or
% % not significant enough.

The next step would be to
extend the work done on \texttt{ADC} and other operations
given in Table~\ref{tab:prvinst} to the full ISS.
% different instruction categories. % JF It is already done!!
% % JF : said above
% The reused parts are the common functions and user-defined tactics,
% which can reduce much of the developing time during proving phase.
% This shorten a lot the current proof script and make it easy
% to understand and to be more generalize.
We are confident that the corresponding work on
the remaining ARM instructions can then be done much faster.
% % JF -> XM : added the following, it would make sense to say
% %  how many lib fun are available / to be done
In particular, a number of lemmas on 14 library functions
are already available.
71 library functions remain to be done.
% % JF: see [GC]
% And it will be also helpful to study the proofs between correctness of
% instructions in the same category.
% The instructions in the same category are constructed
% very similar to each other.
% The common parts then can be
% applied to all instructions in one category.

% Internal functions are described in an informal manner in the
% ARMv6 reference manual.
% No pseudo-code is available for them,
% which means that the corresponding library functions,
% both in the abstract Coq model and in \simlight,
% are written by hand.
% In order to get a suitable \compcert C AST to reason about,
% we use the parser provided in \compcert.
The hand written library functions in \compcert C ASTs are obtained
using the \compcert C parser.
Currently, they are merged with instructions by hand,
and identifiers used in these functions are added manually,
in order to solve a technical issue
stated on page~\pageref{page:libfunast}.
It would be better to build a ``hook'' which automatically finds
the called functions in the parsed ASTs and
generates unused block numbers for the corresponding identifiers.

We also attempted to write a Coq (functional) version of the decoder,
but strong improvements are required to make it usable.
The current version is based on a huge pattern-matching,
%The resulting decoding algorithm is quite weak,
which considers the 32 bits of a binary instruction
in a carefully designed order.
% depending on a roughly concluded decoding order.
% Decoding should be more specific,
% which is one of the very important parts of processor simulator.
We started to design a better version of this decoder,
considering the semantics of bit fields.
% A new version of decoder is planned to decode the binary instruction by the
% bits field separately.
% % [GC] and too technical for a conclusion.
% For example,
% the key bits field $[27:25]$ is $010$ and then
% the instruction must be one of the load/store instruction
% under immediate offset addressing mode;
% or when its value equals to $101$,
% the instruction is a branch instruction.
% After deciding which category it is,
% it should use the other bit field represented parameter
% to decode which concrete instruction it is.
Then, proofs for the decoder could be considered as well
-- automatic extraction tools from the ARM reference manual
are already available.
Finally, the simulation loop
(basically, repeat decoding and running operations) can be be proven.

In another direction, our methodology can be reused on other processors,
such as SH4.

% proof for simlight 2
In the future, \simlight 2 could be considered as well.
\simlight 2 has adopted several optimization methods for a higher simulation
speed. The most important difference is the ``flattening'' method applied
to the instruction set (see Subsection~\ref{sec:codegen}).
Some instructions are merged with their addressing mode,
and the \simlight 2 decoder decodes the instruction and its addressing
mode at the same time. 
Then the C definition is simpler than in \simlight with less function calls.
We expect the proof for this \simlight 2 decoder
to be less difficult than \simlight.
%
Instruction operations in \simlight 2 are essentially the same as for \simlight.
The main optimization used in \simlight 2 
is to specialize some of the parameters according to actually used values.
Therefore, one ARM instruction operation is implemented by
several functions in \simlight 2, instead of just one function in \simlight;
but the code of these functions is essentially the same,
so there is good hope that 
existing correctness lemmas for \simlight could be
restated and generalized in such a way that
instances of them would just be the expected correctness lemmas 
for the corresponding functions in \simlight 2.


% % JF [GC]
% based on automatic
% generation of simulation code and Coq specification for other
% processors.
% The one already considered is SH4.
% In fact, the same approach as the ARMv6 has been followed, and a similar Coq representation can currently be generated from the SH4 manual.
% The other core processor of SimSoC is PowerPC.
% To perform a similar work on PowerPC requires a pre-process replacing using the existing pdf-to-text
% step.
% Because the result of {\stt pdftotxt} is not complete, due to the two column structured documentation, lines are lost or contents
% are disordered.

% % JF : it is not future work
% Besides the correctness proofs on processor instruction operation, the
% other important achievement is building the hand craft version
% \hcinv.
% The technique introduced early in \cite{small_inv} on very small toy examples could be successfully used in a significant application,
% up to suitable extensions in order to conveniently get the premises of
% a constructor in non-absurd cases.
% As in \cite{2013itp}, we do not claim that we have a fully automated tactic, like \inversion.
% Our goal is more modest: providing a hand-crafted inversion technique
% which is flexible enough for the user, so that most practical
% situations can be managed with a full control on the script and
% valuable improvements on robustness.
% Moreover, the extra flexibility provided by hand-crafted inversions can be exploited to produce
% smaller, more manageable proof terms.

% % JF [GC]
% The experiment with SimSoC-Cert correctness proof is introduced in
% Chapter ~\ref{cpt:inv}, which relies on the big inductive relation
% representing the operational semantics of \compcert C defined by
% \compcert project.
Our group recently started another project aiming at
the implementation of certified software written in BIP,
a high-level component-based language dedicated to embedded systems,
with \compcert C as an intermediate target.
We expect the work presented is this thesis to be reused there.
More generally,
our implementation \hcinv dedicated to \compcert
can be re-used in any application of \compcert operational semantics
for proving C programs.
However, it has to be updated accordingly to the new releases of \compcert.

% % JF : it is not future work
% Let us mention another possible application of the technique.
% Inversion is sometimes
% needed to write a function whose properties will be established later (as
% opposed to providing a monolithic and exhaustive Hoare-style specification and
% along with a VC generator such as Program).
% In this context, simply using the proof engine and the \inversion tactic
% tends to generate unmanageably large terms.
% %We can expect our technique could be very helpful in such situations.
% We expect our technique to be very helpful in such situations.

% and the line-count metrics given at the end of \cite{small_inv} makes sense

% reduce developpment time
% ease refactoring a lot


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
