(* File generated by SimSoC-Cert. It provides the definitions of the types
of ARMv6 addressing modes and instructions, and their semantics. *)

Require Import Coqlib Bitvec Util Arm6_Functions Arm6_Config Arm6 Arm6_SCC Arm6_State ZArith Arm6_Message.
Import State Arm6_Functions.Semantics.

(* Addressing mode 1 *)
Inductive mode1 : Type :=
| M1_Immediate (immed_8 : word) (rotate_imm : word)
| M1_Register (m : regnum)
| M1_Logical_shift_left_by_immediate (m : regnum) (shift_imm : word)
| M1_Logical_shift_left_by_register (m : regnum) (s : regnum)
| M1_Logical_shift_right_by_immediate (m : regnum) (shift_imm : word)
| M1_Logical_shift_right_by_register (m : regnum) (s : regnum)
| M1_Arithmetic_shift_right_by_immediate (m : regnum) (shift_imm : word)
| M1_Arithmetic_shift_right_by_register (m : regnum) (s : regnum)
| M1_Rotate_right_by_immediate (m : regnum) (shift_imm : word)
| M1_Rotate_right_by_register (m : regnum) (s : regnum)
| M1_Rotate_right_with_extend (m : regnum).

(* Addressing mode 2 *)
Inductive mode2 : Type :=
| M2_Immediate_offset (U : bool) (n : regnum) (offset_12 : word)
| M2_Register_offset (U : bool) (m : regnum) (n : regnum)
| M2_Scaled_register_offset (U : bool) (m : regnum) (n : regnum) (shift : word) (shift_imm : word)
| M2_Immediate_pre_indexed (U : bool) (cond : opcode) (n : regnum) (offset_12 : word)
| M2_Register_pre_indexed (U : bool) (cond : opcode) (m : regnum) (n : regnum)
| M2_Scaled_register_pre_indexed (U : bool) (cond : opcode) (m : regnum) (n : regnum) (shift : word) (shift_imm : word)
| M2_Immediate_post_indexed (U : bool) (cond : opcode) (n : regnum) (offset_12 : word)
| M2_Register_post_indexed (U : bool) (cond : opcode) (m : regnum) (n : regnum)
| M2_Scaled_register_post_indexed (U : bool) (cond : opcode) (m : regnum) (n : regnum) (shift : word) (shift_imm : word).

(* Addressing mode 3 *)
Inductive mode3 : Type :=
| M3_Immediate_offset (U : bool) (immedH : word) (immedL : word) (n : regnum)
| M3_Register_offset (U : bool) (m : regnum) (n : regnum)
| M3_Immediate_pre_indexed (U : bool) (cond : opcode) (immedH : word) (immedL : word) (n : regnum)
| M3_Register_pre_indexed (U : bool) (cond : opcode) (m : regnum) (n : regnum)
| M3_Immediate_post_indexed (U : bool) (cond : opcode) (immedH : word) (immedL : word) (n : regnum)
| M3_Register_post_indexed (U : bool) (cond : opcode) (m : regnum) (n : regnum).

(* Addressing mode 4 *)
Inductive mode4 : Type :=
| M4_Increment_after (W : bool) (cond : opcode) (n : regnum) (register_list : word)
| M4_Increment_before (W : bool) (cond : opcode) (n : regnum) (register_list : word)
| M4_Decrement_after (W : bool) (cond : opcode) (n : regnum) (register_list : word)
| M4_Decrement_before (W : bool) (cond : opcode) (n : regnum) (register_list : word).

(* Addressing mode 5 *)
Inductive mode5 : Type :=
| M5_Immediate_offset (U : bool) (cond : opcode) (cp_num : word) (n : regnum) (offset_8 : word)
| M5_Immediate_pre_indexed (U : bool) (cond : opcode) (cp_num : word) (n : regnum) (offset_8 : word)
| M5_Immediate_post_indexed (U : bool) (cond : opcode) (cp_num : word) (n : regnum) (offset_8 : word)
| M5_Unindexed (cond : opcode) (cp_num : word) (n : regnum).

(* Instructions *)
Inductive inst : Type :=
| ADC (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| ADD (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| AND (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| B (L : bool) (cond : opcode) (signed_immed_24 : word)
| BIC (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| BKPT
| BLX1 (H : bool) (signed_immed_24 : word)
| BLX2 (cond : opcode) (m : regnum)
| BX (cond : opcode) (m : regnum)
| BXJ (cond : opcode) (m : regnum)
| CDP (cond : opcode) (cp_num : word)
| CLZ (cond : opcode) (d : regnum) (m : regnum)
| CMN (m_ : mode1) (cond : opcode) (n : regnum)
| CMP (m_ : mode1) (cond : opcode) (n : regnum)
| CPS (A : bool) (F : bool) (I : bool) (imod : word) (mmod : bool) (mode : word)
| CPY (cond : opcode) (d : regnum) (m : regnum)
| EOR (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| LDC (m_ : mode5) (cond : opcode) (cp_num : word)
| LDM1 (m_ : mode4) (cond : opcode) (register_list : word)
| LDM2 (m_ : mode4) (cond : opcode) (register_list : word)
| LDM3 (m_ : mode4) (cond : opcode) (register_list : word)
| LDR (m_ : mode2) (cond : opcode) (d : regnum)
| LDRB (m_ : mode2) (cond : opcode) (d : regnum)
| LDRBT (m_ : mode2) (cond : opcode) (d : regnum)
| LDRD (m_ : mode3) (cond : opcode) (d : regnum)
| LDREX (cond : opcode) (d : regnum) (n : regnum)
| LDRH (m_ : mode3) (cond : opcode) (d : regnum)
| LDRSB (m_ : mode3) (cond : opcode) (d : regnum)
| LDRSH (m_ : mode3) (cond : opcode) (d : regnum)
| LDRT (m_ : mode2) (cond : opcode) (d : regnum)
| MCR (cond : opcode) (cp_num : word) (d : regnum)
| MCRR (cond : opcode) (cp_num : word) (d : regnum) (n : regnum)
| MLA (S : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum)
| MOV (m_ : mode1) (S : bool) (cond : opcode) (d : regnum)
| MRC (cond : opcode) (cp_num : word) (d : regnum)
| MRRC (cond : opcode) (cp_num : word) (d : regnum) (n : regnum)
| MRS (R : bool) (cond : opcode) (d : regnum)
| MSRimm (R : bool) (cond : opcode) (field_mask : word) (immed_8 : word) (rotate_imm : word)
| MSRreg (R : bool) (cond : opcode) (field_mask : word) (m : regnum)
| MUL (S : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum)
| MVN (m_ : mode1) (S : bool) (cond : opcode) (d : regnum)
| ORR (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| PKHBT (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (shift_imm : word)
| PKHTB (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (shift_imm : word)
| PLD
| QADD (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QADD16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QADD8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QADDSUBX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QDADD (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QDSUB (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QSUB (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QSUB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QSUB8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| QSUBADDX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| REV (cond : opcode) (d : regnum) (m : regnum)
| REV16 (cond : opcode) (d : regnum) (m : regnum)
| REVSH (cond : opcode) (d : regnum) (m : regnum)
| RFE (m_ : mode4)
| RSB (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| RSC (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| SADD16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SADD8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SADDSUBX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SBC (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| SEL (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SETEND (E : bool)
| SHADD16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SHADD8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SHADDSUBX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SHSUB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SHSUB8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SHSUBADDX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SMLAxy (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) (x : bool) (y : bool)
| SMLAD (X : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum)
| SMLAL (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum)
| SMLALxy (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) (x : bool) (y : bool)
| SMLALD (X : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum)
| SMLAWy (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) (y : bool)
| SMLSD (X : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum)
| SMLSLD (X : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum)
| SMMLA (R : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum)
| SMMLS (R : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum)
| SMMUL (R : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum)
| SMUAD (X : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum)
| SMULxy (cond : opcode) (d : regnum) (m : regnum) (s : regnum) (x : bool) (y : bool)
| SMULL (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum)
| SMULWy (cond : opcode) (d : regnum) (m : regnum) (s : regnum) (y : bool)
| SMUSD (X : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum)
| SRS (m_ : mode4)
| SSAT (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word) (shift : bool) (shift_imm : word)
| SSAT16 (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word)
| SSUB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SSUB8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SSUBADDX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| STC (m_ : mode5) (cond : opcode) (cp_num : word)
| STM1 (m_ : mode4) (cond : opcode) (register_list : word)
| STM2 (m_ : mode4) (cond : opcode) (register_list : word)
| STR (m_ : mode2) (cond : opcode) (d : regnum)
| STRB (m_ : mode2) (cond : opcode) (d : regnum)
| STRBT (m_ : mode2) (cond : opcode) (d : regnum)
| STRD (m_ : mode3) (cond : opcode) (d : regnum)
| STREX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| STRH (m_ : mode3) (cond : opcode) (d : regnum)
| STRT (m_ : mode2) (cond : opcode) (d : regnum)
| SUB (m_ : mode1) (S : bool) (cond : opcode) (d : regnum) (n : regnum)
| SWI (cond : opcode)
| SWP (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SWPB (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| SXTAB (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word)
| SXTAB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word)
| SXTAH (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word)
| SXTB (cond : opcode) (d : regnum) (m : regnum) (rotate : word)
| SXTB16 (cond : opcode) (d : regnum) (m : regnum) (rotate : word)
| SXTH (cond : opcode) (d : regnum) (m : regnum) (rotate : word)
| TEQ (m_ : mode1) (cond : opcode) (n : regnum)
| TST (m_ : mode1) (cond : opcode) (n : regnum)
| UADD16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UADD8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UADDSUBX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UHADD16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UHADD8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UHADDSUBX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UHSUB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UHSUB8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UHSUBADDX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UMAAL (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum)
| UMLAL (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum)
| UMULL (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum)
| UQADD16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UQADD8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UQADDSUBX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UQSUB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UQSUB8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UQSUBADDX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| USAD8 (cond : opcode) (d : regnum) (m : regnum) (s : regnum)
| USADA8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum)
| USAT (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word) (shift : bool) (shift_imm : word)
| USAT16 (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word)
| USUB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| USUB8 (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| USUBADDX (cond : opcode) (d : regnum) (m : regnum) (n : regnum)
| UXTAB (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word)
| UXTAB16 (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word)
| UXTAH (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word)
| UXTB (cond : opcode) (d : regnum) (m : regnum) (rotate : word)
| UXTB16 (cond : opcode) (d : regnum) (m : regnum) (rotate : word)
| UXTH (cond : opcode) (d : regnum) (m : regnum) (rotate : word).

(* Semantic functions of addressing modes and instructions *)
Module InstSem (Import C : CONFIG).
Definition ret_ {A} (x : A) := ret (true, x).

(* A4.1.2 ADC *)
Definition ADC_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (add (add (reg_content s0 n) shifter_operand) ((cpsr st)[Cbit]))
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit (CarryFrom_add3 (reg_content s0 n) shifter_operand ((cpsr st)[Cbit]))
           ; <st> set_cpsr_bit Vbit (OverflowFrom_add3 (reg_content s0 n) shifter_operand ((cpsr st)[Cbit])) ])) ]).

(* A4.1.3 ADD *)
Definition ADD_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (add (reg_content s0 n) shifter_operand)
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit (CarryFrom_add2 (reg_content s0 n) shifter_operand)
           ; <st> set_cpsr_bit Vbit (OverflowFrom_add2 (reg_content s0 n) shifter_operand) ])) ]).

(* A4.1.4 AND *)
Definition AND_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (and (reg_content s0 n) shifter_operand)
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit shifter_carry_out ])) ]).

(* A4.1.5 B, BL *)
Definition B_step (L : bool) (cond : opcode) (signed_immed_24 : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ if_then (zeq L 1)
         (<st> set_reg LR (address_of_next_instruction st))
    ; <st> set_reg PC (add (reg_content st PC) (Logical_Shift_Left (SignExtend_30 signed_immed_24) (repr 2))) ]).

(* A4.1.6 BIC *)
Definition BIC_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (and (reg_content s0 n) (not shifter_operand))
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit shifter_carry_out ])) ]).

(* A4.1.7 BKPT *)
Definition BKPT_step : semfun _ := <s0>
  if_then (not_overridden_by_debug_hardware)
    ([ <st> set_reg_mode (exn abt) LR (add (address_of_current_instruction st) (repr 4))
    ; <st> set_spsr abt (cpsr st)
    ; <st> set_cpsr (set_bits n4 n0 (repr (Zpos 1~0~1~1~1)) (cpsr st))
    ; <st> set_cpsr (set_bit n5 (repr 0) (cpsr st))
    ; <st> set_cpsr (set_bit n7 (repr 1) (cpsr st))
    ; <st> set_cpsr (set_bit n8 (repr 1) (cpsr st))
    ; <st> set_cpsr (set_bit n9 ((CP15_reg1 st)[EEbit]) (cpsr st))
    ; <st> If (high_vectors_configured st)
       then         (<st> set_reg PC (repr (Zpos 4294901772)))
       else         (<st> set_reg PC (repr (Zpos 12))) ]).

(* A4.1.8 BLX (1) *)
Definition BLX1_step (H : bool) (signed_immed_24 : word) : semfun _ := <s0>
  [ <st> set_reg LR (address_of_next_instruction st)
  ; <st> set_cpsr_bit Tbit (repr 1)
  ; <st> set_reg PC (add (add (reg_content st PC) (Logical_Shift_Left (SignExtend_30 signed_immed_24) (repr 2))) (Logical_Shift_Left H (repr 1))) ].

(* A4.1.9 BLX (2) *)
Definition BLX2_step (cond : opcode) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let target := reg_content s0 m in
    [ <st> set_reg LR (address_of_next_instruction st)
      ; <st> set_cpsr_bit Tbit (target[n0])
      ; <st> set_reg PC (and target (repr (Zpos 4294967294))) ]]).

(* A4.1.10 BX *)
Definition BX_step (cond : opcode) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_cpsr_bit Tbit ((reg_content s0 m)[n0])
    ; <st> set_reg PC (and (reg_content s0 m) (repr (Zpos 4294967294))) ]).

(* A4.1.11 BXJ *)
Definition BXJ_step (cond : opcode) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (If (zeq C.JE_bit_of_Main_Configuration_register 0)
    then      ([ <st> set_cpsr_bit Tbit ((reg_content s0 m)[n0])
      ; <st> set_reg PC (and (reg_content s0 m) (repr (Zpos 4294967294))) ])
    else      ([ let jpc := C.jpc_SUB_ARCHITECTURE_DEFINED_value in
      let invalidhandler := C.invalidhandler_SUB_ARCHITECTURE_DEFINED_value in
      [ If (C.Jazelle_Extension_accepts_opcode_at jpc)
         then           (If (zeq C.CV_bit_of_Jazelle_OS_Control_register 0)
           then             (<st> set_reg PC invalidhandler)
           else             ([ <st> set_cpsr_bit Jbit (repr 1)
             ; @todo unit StartOpcodeExecutionAt (* Start_opcode_execution_at(jpc); *) ]))
         else           (If (andb (zeq C.CV_bit_of_Jazelle_OS_Control_register 0) (IMPLEMENTATION_DEFINED_CONDITION))
           then             (<st> set_reg PC invalidhandler)
           else             ([ <st> set_cpsr_bit Tbit ((reg_content s0 m)[n0])
             ; <st> set_reg PC (and (reg_content s0 m) (repr (Zpos 4294967294))) ])) ]])).

(* A4.1.12 CDP *)
Definition CDP_step (cond : opcode) (cp_num : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (@todo unit Coproc (* Coprocessor[cp_num] dependent_operation *)).

(* A4.1.13 CLZ *)
Definition CLZ_step (cond : opcode) (d : regnum) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (If (zeq (reg_content s0 m) 0)
    then      (<st> set_reg d (repr 32))
    else      (<st> set_reg d (sub (repr 31) (bit_position_of_most_significant_1 (reg_content s0 m))))).

(* A4.1.14 CMN *)
Definition CMN_step (cond : opcode) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let alu_out := add (reg_content s0 n) shifter_operand in
    [ <st> set_cpsr_bit Nbit (alu_out[n31])
      ; <st> set_cpsr_bit Zbit (if zeq alu_out 0 then repr 1 else repr 0)
      ; <st> set_cpsr_bit Cbit (CarryFrom_add2 (reg_content s0 n) shifter_operand)
      ; <st> set_cpsr_bit Vbit (OverflowFrom_add2 (reg_content s0 n) shifter_operand) ]]).

(* A4.1.15 CMP *)
Definition CMP_step (cond : opcode) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let alu_out := sub (reg_content s0 n) shifter_operand in
    [ <st> set_cpsr_bit Nbit (alu_out[n31])
      ; <st> set_cpsr_bit Zbit (if zeq alu_out 0 then repr 1 else repr 0)
      ; <st> set_cpsr_bit Cbit (negb (BorrowFrom_sub2 (reg_content s0 n) shifter_operand))
      ; <st> set_cpsr_bit Vbit (OverflowFrom_sub2 (reg_content s0 n) shifter_operand) ]]).

(* A4.1.16 CPS *)
Definition CPS_step (A : bool) (F : bool) (I : bool) (imod : word) (mmod : bool) (mode : word) : semfun _ := <s0>
  if_then (InAPrivilegedMode s0)
    ([ if_then (zeq (imod[n1]) 1)
         ([ if_then (zeq A 1)
              (<st> set_cpsr (set_bit n8 (imod[n0]) (cpsr st)))
         ; if_then (zeq I 1)
              (<st> set_cpsr (set_bit n7 (imod[n0]) (cpsr st)))
         ; if_then (zeq F 1)
              (<st> set_cpsr (set_bit n6 (imod[n0]) (cpsr st))) ])
    ; if_then (zeq mmod 1)
         (<st> set_cpsr (set_bits n4 n0 mode (cpsr st))) ]).

(* A4.1.17 CPY *)
Definition CPY_step (cond : opcode) (d : regnum) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> set_reg d (reg_content s0 m)).

(* A4.1.18 EOR *)
Definition EOR_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (xor (reg_content s0 n) shifter_operand)
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit shifter_carry_out ])) ]).

(* A4.1.19 LDC *)
Definition LDC_step (cond : opcode) (cp_num : word) (start_address : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*address*) start_address
    ; <:loc st:> @todo unit Coproc (* load Memory[address,4] for Coprocessor[cp_num] *)
    ; <:loc st:> @todo unit While (* while NotFinished(Coprocessor[cp_num]) do
    begin
    address = address + 4;
    load Memory[address,4] for Coprocessor[cp_num]
    end *) ]).

(* A4.1.20 LDM (1) *)
Definition LDM1_step (cond : opcode) (register_list : word) (start_address : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*address*) start_address
    ; loop 0 n14 (fun i => 
         if_then (zeq (register_list[i]) 1)
           ([ <:loc st:> set_reg i (read st (get_loc n0 (*address*) loc) size_Word)
           ; <.loc.> update_loc n0 (*address*) (add (get_loc n0 (*address*) loc) (repr 4)) ]))
    ; if_then (zeq (register_list[n15]) 1)
         ([ <:loc st:> let value := read st (get_loc n0 (*address*) loc) size_Word in
         [ <st> set_reg PC (and value (repr (Zpos 4294967294)))
           ; <st> set_cpsr_bit Tbit (value[n0])
           ; <.loc.> update_loc n0 (*address*) (add (get_loc n0 (*address*) loc) (repr 4)) ]]) ]).

(* A4.1.21 LDM (2) *)
Definition LDM2_step (cond : opcode) (register_list : word) (start_address : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*address*) start_address
    ; loop 0 n14 (fun i => 
         if_then (zeq (register_list[i]) 1)
           ([ <:loc st:> set_reg_mode usr i (read st (get_loc n0 (*address*) loc) size_Word)
           ; <.loc.> update_loc n0 (*address*) (add (get_loc n0 (*address*) loc) (repr 4)) ])) ]).

(* A4.1.22 LDM (3) *)
Definition LDM3_step (cond : opcode) (register_list : word) (start_address : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*address*) start_address
    ; loop 0 n14 (fun i => 
         if_then (zeq (register_list[i]) 1)
           ([ <:loc st:> set_reg i (read st (get_loc n0 (*address*) loc) size_Word)
           ; <.loc.> update_loc n0 (*address*) (add (get_loc n0 (*address*) loc) (repr 4)) ]))
    ; <st> if_CurrentModeHasSPSR (fun em =>
         (<st> set_cpsr (spsr st em)))
    ; <:loc st:> let value := read st (get_loc n0 (*address*) loc) size_Word in
    [ <st> set_reg PC value
      ; <.loc.> update_loc n0 (*address*) (add (get_loc n0 (*address*) loc) (repr 4)) ]]).

(* A4.1.23 LDR *)
Definition LDR_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> let data := if zeq ((CP15_reg1 st)[Ubit]) 0 then Rotate_Right (read st address size_Word) (mul (repr 8) (address[n1#n0])) else read st address size_Word in
    [ If (zeq d 15)
       then         ([ <st> set_reg PC (and data (repr (Zpos 4294967294)))
         ; <st> set_cpsr_bit Tbit (data[n0]) ])
       else         (<st> set_reg d data) ]]).

(* A4.1.24 LDRB *)
Definition LDRB_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> set_reg d (read st address size_Byte)).

(* A4.1.25 LDRBT *)
Definition LDRBT_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> set_reg d (read st address size_Byte)).

(* A4.1.26 LDRD *)
Definition LDRD_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> If (andb (andb (andb (is_even d) (zne d (repr 14))) (zeq (address[n1#n0]) (repr (Z0)))) (orb (zeq ((CP15_reg1 st)[Ubit]) 1) (zeq (address[n2]) 0)))
    then      ([ <st> set_reg d (read st address size_Word)
      ; <st> set_reg (mk_regnum (add d (repr 1))) (read st (add address (repr 4)) size_Word) ])
    else      (unpredictable EmptyMessage)).

(* A4.1.27 LDREX *)
Definition LDREX_step (cond : opcode) (d : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> let processor_id := ExecutingProcessor st in
    [ <st> set_reg d (read st (reg_content s0 n) size_Word)
      ; <st> let physical_address := TLB st (reg_content s0 n) in
      [ <st> if_then (zeq (Shared st (reg_content s0 n)) 1)
         (MarkExclusiveGlobal physical_address processor_id n4)
        ; MarkExclusiveLocal physical_address processor_id n4 ]]]).

(* A4.1.28 LDRH *)
Definition LDRH_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> if_then (andb (zeq ((CP15_reg1 st)[Ubit]) 0) (negb (zeq (address[n0]) 0)))
         (unpredictable EmptyMessage)
    ; <st> let data := read st address size_Half in
    [ <st> set_reg d ((*ZeroExtend*)(get_half0 data)) ]]).

(* A4.1.29 LDRSB *)
Definition LDRSB_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> let data := read st address size_Byte in
    [ <st> set_reg d (SignExtend8 data) ]]).

(* A4.1.30 LDRSH *)
Definition LDRSH_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> if_then (andb (zeq ((CP15_reg1 st)[Ubit]) 0) (negb (zeq (address[n0]) 0)))
         (unpredictable EmptyMessage)
    ; <st> let data := read st address size_Half in
    [ <st> set_reg d (SignExtend16 (get_half0 data)) ]]).

(* A4.1.31 LDRT *)
Definition LDRT_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> If (zeq ((CP15_reg1 st)[Ubit]) 0)
    then      (<st> set_reg d (Rotate_Right (read st address size_Word) (mul (repr 8) (address[n1#n0]))))
    else      (<st> set_reg d (read st address size_Word))).

(* A4.1.32 MCR *)
Definition MCR_step (cond : opcode) (cp_num : word) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> @todo unit Coproc (* send Rd to Coprocessor[cp_num] *)).

(* A4.1.33 MCRR *)
Definition MCRR_step (cond : opcode) (cp_num : word) (d : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> @todo unit Coproc (* send Rd to Coprocessor[cp_num] *)
    ; @todo unit Coproc (* send Rn to Coprocessor[cp_num] *) ]).

(* A4.1.34 MLA *)
Definition MLA_step (S : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (get_lo (add (mul (reg_content s0 m) (reg_content s0 s)) (reg_content s0 n)))
    ; if_then (zeq S 1)
         ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
         ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0) ]) ]).

(* A4.1.35 MOV *)
Definition MOV_step (S : bool) (cond : opcode) (d : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d shifter_operand
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit shifter_carry_out ])) ]).

(* A4.1.36 MRC *)
Definition MRC_step (cond : opcode) (cp_num : word) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let data := (*todo: value from Coprocessor[cp_num]*) (repr 0) in
    [ If (zeq d 15)
       then         ([ <st> set_cpsr_bit Nbit (data[n31])
         ; <st> set_cpsr_bit Zbit (data[n30])
         ; <st> set_cpsr_bit Cbit (data[n29])
         ; <st> set_cpsr_bit Vbit (data[n28]) ])
       else         (<st> set_reg d data) ]]).

(* A4.1.37 MRRC *)
Definition MRRC_step (cond : opcode) (cp_num : word) (d : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d ((*todo: first_value from Coprocessor[cp_num]*) (repr 0))
    ; set_reg n ((*todo: second_value from Coprocessor[cp_num]*) (repr 0)) ]).

(* A4.1.38 MRS *)
Definition MRS_step (R : bool) (cond : opcode) (d : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (if_then_else (zeq R 1) (if_CurrentModeHasSPSR (fun em =>
      (<st> set_reg d (spsr st em))))
      (<st> set_reg d (cpsr st))).

(* A4.1.39 MSRimm *)
Definition MSRimm_step (R : bool) (cond : opcode) (field_mask : word) (immed_8 : word) (rotate_imm : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand := Rotate_Right immed_8 (mul rotate_imm (repr 2)) in
    [ if_then (zne (and operand (UnallocMask)) (repr 0))
         (unpredictable EmptyMessage)
      ; let byte_mask := or (or (or (if zeq (field_mask[n0]) 1 then repr (Zpos 255) else repr (Z0)) (if zeq (field_mask[n1]) 1 then repr (Zpos 65280) else repr (Z0))) (if zeq (field_mask[n2]) 1 then repr (Zpos 16711680) else repr (Z0))) (if zeq (field_mask[n3]) 1 then repr (Zpos 4278190080) else repr (Z0)) in
      [ If (zeq R 0)
       then         ([ if_then (andb (InAPrivilegedMode s0) (zne (and operand (StateMask)) (repr 0)))
              (unpredictable EmptyMessage)
         ; update_loc n0 (*mask*) (if negb (InAPrivilegedMode s0) then and byte_mask (UserMask) else and byte_mask (or (UserMask) (PrivMask)))
         ; <:loc st:> set_cpsr (or (and (cpsr st) (not (get_loc n0 (*mask*) loc))) (and operand (get_loc n0 (*mask*) loc))) ])
       else         (<:loc st:> if_CurrentModeHasSPSR (fun em =>
           ([ update_loc n0 (*mask*) (and byte_mask (or (or (UserMask) (PrivMask)) (StateMask)))
           ; <:loc st:> set_spsr em (or (and (spsr st em) (not (get_loc n0 (*mask*) loc))) (and operand (get_loc n0 (*mask*) loc))) ]))) ]]]).

(* A4.1.39 MSRreg *)
Definition MSRreg_step (R : bool) (cond : opcode) (field_mask : word) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand := reg_content s0 m in
    [ if_then (zne (and operand (UnallocMask)) (repr 0))
         (unpredictable EmptyMessage)
      ; let byte_mask := or (or (or (if zeq (field_mask[n0]) 1 then repr (Zpos 255) else repr (Z0)) (if zeq (field_mask[n1]) 1 then repr (Zpos 65280) else repr (Z0))) (if zeq (field_mask[n2]) 1 then repr (Zpos 16711680) else repr (Z0))) (if zeq (field_mask[n3]) 1 then repr (Zpos 4278190080) else repr (Z0)) in
      [ If (zeq R 0)
       then         ([ if_then (andb (InAPrivilegedMode s0) (zne (and operand (StateMask)) (repr 0)))
              (unpredictable EmptyMessage)
         ; update_loc n0 (*mask*) (if negb (InAPrivilegedMode s0) then and byte_mask (UserMask) else and byte_mask (or (UserMask) (PrivMask)))
         ; <:loc st:> set_cpsr (or (and (cpsr st) (not (get_loc n0 (*mask*) loc))) (and operand (get_loc n0 (*mask*) loc))) ])
       else         (<:loc st:> if_CurrentModeHasSPSR (fun em =>
           ([ update_loc n0 (*mask*) (and byte_mask (or (or (UserMask) (PrivMask)) (StateMask)))
           ; <:loc st:> set_spsr em (or (and (spsr st em) (not (get_loc n0 (*mask*) loc))) (and operand (get_loc n0 (*mask*) loc))) ]))) ]]]).

(* A4.1.40 MUL *)
Definition MUL_step (S : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d ((mul (reg_content s0 m) (reg_content s0 s))[n31#n0])
    ; if_then (zeq S 1)
         ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
         ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0) ]) ]).

(* A4.1.41 MVN *)
Definition MVN_step (S : bool) (cond : opcode) (d : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (not shifter_operand)
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit shifter_carry_out ])) ]).

(* A4.1.42 ORR *)
Definition ORR_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (or (reg_content s0 n) shifter_operand)
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit shifter_carry_out ])) ]).

(* A4.1.43 PKHBT *)
Definition PKHBT_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (shift_imm : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (get_half0 (reg_content s0 n)) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (get_half1 (Logical_Shift_Left (reg_content s0 m) shift_imm)) (reg_content st d)) ]).

(* A4.1.44 PKHTB *)
Definition PKHTB_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (shift_imm : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ If (zeq shift_imm 0)
       then         (If (zeq ((reg_content s0 m)[n31]) 0)
         then           (<st> set_reg d (set_bits n15 n0 (repr (Z0)) (reg_content st d)))
         else           (<st> set_reg d (set_bits n15 n0 (repr (Zpos 65535)) (reg_content st d))))
       else         (<st> set_reg d (set_bits n15 n0 (get_half0 (Arithmetic_Shift_Right (reg_content s0 m) shift_imm)) (reg_content st d)))
    ; <st> set_reg d (set_bits n31 n16 (get_half1 (reg_content s0 n)) (reg_content st d)) ]).

(* A4.1.45 PLD *)
Definition PLD_step : semfun _ := <s0>
  [ ].

(* A4.1.46 QADD *)
Definition QADD_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (SignedSat32_add (reg_content s0 m) (reg_content s0 n))
    ; if_then (SignedDoesSat32_add (reg_content s0 m) (reg_content s0 n))
         (<st> set_cpsr_bit Qbit (repr 1)) ]).

(* A4.1.47 QADD16 *)
Definition QADD16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (SignedSat (add (get_signed_half0 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (SignedSat (add (get_signed_half1 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.48 QADD8 *)
Definition QADD8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n7 n0 (SignedSat (add (get_signed_byte0 (reg_content s0 n)) (get_signed_byte0 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n8 (SignedSat (add (get_signed_byte1 (reg_content s0 n)) (get_signed_byte1 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n23 n16 (SignedSat (add (get_signed_byte2 (reg_content s0 n)) (get_signed_byte2 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n24 (SignedSat (add (get_signed_byte3 (reg_content s0 n)) (get_signed_byte3 (reg_content s0 m))) n8) (reg_content st d)) ]).

(* A4.1.49 QADDSUBX *)
Definition QADDSUBX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n31 n16 (SignedSat (add (get_signed_half1 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n0 (SignedSat (sub (get_signed_half0 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.50 QDADD *)
Definition QDADD_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (SignedSat32_add (reg_content s0 m) (SignedSat32_double (reg_content s0 n)))
    ; if_then (orb (SignedDoesSat32_add (reg_content s0 m) (SignedSat32_double (reg_content s0 n))) (SignedDoesSat32_double (reg_content s0 n)))
         (<st> set_cpsr_bit Qbit (repr 1)) ]).

(* A4.1.51 QDSUB *)
Definition QDSUB_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (SignedSat32_sub (reg_content s0 m) (SignedSat32_double (reg_content s0 n)))
    ; if_then (orb (SignedDoesSat32_sub (reg_content s0 m) (SignedSat32_double (reg_content s0 n))) (SignedDoesSat32_double (reg_content s0 n)))
         (<st> set_cpsr_bit Qbit (repr 1)) ]).

(* A4.1.52 QSUB *)
Definition QSUB_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (SignedSat32_sub (reg_content s0 m) (reg_content s0 n))
    ; if_then (SignedDoesSat32_sub (reg_content s0 m) (reg_content s0 n))
         (<st> set_cpsr_bit Qbit (repr 1)) ]).

(* A4.1.53 QSUB16 *)
Definition QSUB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (SignedSat (sub (get_signed_half0 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (SignedSat (sub (get_signed_half1 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.54 QSUB8 *)
Definition QSUB8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n7 n0 (SignedSat (sub (get_signed_byte0 (reg_content s0 n)) (get_signed_byte0 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n8 (SignedSat (sub (get_signed_byte1 (reg_content s0 n)) (get_signed_byte1 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n23 n16 (SignedSat (sub (get_signed_byte2 (reg_content s0 n)) (get_signed_byte2 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n24 (SignedSat (sub (get_signed_byte3 (reg_content s0 n)) (get_signed_byte3 (reg_content s0 m))) n8) (reg_content st d)) ]).

(* A4.1.55 QSUBADDX *)
Definition QSUBADDX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n31 n16 (SignedSat (sub (get_signed_half1 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n0 (SignedSat (add (get_signed_half0 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.56 REV *)
Definition REV_step (cond : opcode) (d : regnum) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n31 n24 (get_byte0 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n23 n16 (get_byte1 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n8 (get_byte2 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n7 n0 (get_byte3 (reg_content s0 m)) (reg_content st d)) ]).

(* A4.1.57 REV16 *)
Definition REV16_step (cond : opcode) (d : regnum) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n8 (get_byte0 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n7 n0 (get_byte1 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n24 (get_byte2 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n23 n16 (get_byte3 (reg_content s0 m)) (reg_content st d)) ]).

(* A4.1.58 REVSH *)
Definition REVSH_step (cond : opcode) (d : regnum) (m : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n8 (get_byte0 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n7 n0 (get_byte1 (reg_content s0 m)) (reg_content st d))
    ; If (zeq ((reg_content s0 m)[n7]) 1)
       then         (<st> set_reg d (set_bits n31 n16 (repr (Zpos 65535)) (reg_content st d)))
       else         (<st> set_reg d (set_bits n31 n16 (repr (Z0)) (reg_content st d))) ]).

(* A4.1.59 RFE *)
Definition RFE_step (start_address : word) : semfun _ := <s0>
  [ <st> let address := start_address in
  let value := read st address size_Word in
  [ If (InAPrivilegedMode s0)
     then       (<st> set_cpsr (read st (add address (repr 4)) size_Word))
     else       (unpredictable EmptyMessage)
    ; <st> set_reg PC value ]].

(* A4.1.60 RSB *)
Definition RSB_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (sub shifter_operand (reg_content s0 n))
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit (negb (BorrowFrom_sub2 shifter_operand (reg_content s0 n)))
           ; <st> set_cpsr_bit Vbit (OverflowFrom_sub2 shifter_operand (reg_content s0 n)) ])) ]).

(* A4.1.61 RSC *)
Definition RSC_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (sub (sub shifter_operand (reg_content s0 n)) (negb (bool_of_word ((cpsr st)[Cbit]))))
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit (negb (BorrowFrom_sub3 shifter_operand (reg_content s0 n) (negb (bool_of_word ((cpsr st)[Cbit])))))
           ; <st> set_cpsr_bit Vbit (OverflowFrom_sub3 shifter_operand (reg_content s0 n) (negb (bool_of_word ((cpsr st)[Cbit])))) ])) ]).

(* A4.1.62 SADD16 *)
Definition SADD16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*sum*) (add (get_signed_half0 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n0 (get_signed_half0 (get_loc n0 (*sum*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bits n17 n16 (if ge_0 (get_loc n0 (*sum*) loc) then repr (Zpos 1~1) else repr 0) (cpsr st))
    ; update_loc n0 (*sum*) (add (get_signed_half1 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n16 (get_signed_half0 (get_loc n0 (*sum*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bits n19 n18 (if ge_0 (get_loc n0 (*sum*) loc) then repr (Zpos 1~1) else repr 0) (cpsr st)) ]).

(* A4.1.63 SADD8 *)
Definition SADD8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*sum*) (add (get_signed_byte0 (reg_content s0 n)) (get_signed_byte0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n7 n0 (get_signed_byte0 (get_loc n0 (*sum*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n16 (if ge_0 (get_loc n0 (*sum*) loc) then repr 1 else repr 0) (cpsr st))
    ; update_loc n0 (*sum*) (add (get_signed_byte1 (reg_content s0 n)) (get_signed_byte1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n8 (get_signed_byte0 (get_loc n0 (*sum*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n17 (if ge_0 (get_loc n0 (*sum*) loc) then repr 1 else repr 0) (cpsr st))
    ; update_loc n0 (*sum*) (add (get_signed_byte2 (reg_content s0 n)) (get_signed_byte2 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n23 n16 (get_signed_byte0 (get_loc n0 (*sum*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n18 (if ge_0 (get_loc n0 (*sum*) loc) then repr 1 else repr 0) (cpsr st))
    ; update_loc n0 (*sum*) (add (get_signed_byte3 (reg_content s0 n)) (get_signed_byte3 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n24 (get_signed_byte0 (get_loc n0 (*sum*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n19 (if ge_0 (get_loc n0 (*sum*) loc) then repr 1 else repr 0) (cpsr st)) ]).

(* A4.1.64 SADDSUBX *)
Definition SADDSUBX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let sum := add (get_signed_half1 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (get_signed_half0 sum) (reg_content st d))
      ; <st> set_cpsr (set_bits n19 n18 (if ge_0 sum then repr (Zpos 1~1) else repr 0) (cpsr st))
      ; let diff := sub (get_signed_half0 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (get_signed_half0 diff) (reg_content st d))
        ; <st> set_cpsr (set_bits n17 n16 (if ge_0 diff then repr (Zpos 1~1) else repr 0) (cpsr st)) ]]]).

(* A4.1.65 SBC *)
Definition SBC_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (sub (sub (reg_content s0 n) shifter_operand) (negb (bool_of_word ((cpsr st)[Cbit]))))
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit (negb (BorrowFrom_sub3 (reg_content s0 n) shifter_operand (negb (bool_of_word ((cpsr st)[Cbit])))))
           ; <st> set_cpsr_bit Vbit (OverflowFrom_sub3 (reg_content s0 n) shifter_operand (negb (bool_of_word ((cpsr st)[Cbit])))) ])) ]).

(* A4.1.66 SEL *)
Definition SEL_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n7 n0 (if zeq ((cpsr st)[n16]) 1 then get_signed_byte0 (reg_content s0 n) else get_signed_byte0 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n8 (if zeq ((cpsr st)[n17]) 1 then get_signed_byte1 (reg_content s0 n) else get_signed_byte1 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n23 n16 (if zeq ((cpsr st)[n18]) 1 then get_signed_byte2 (reg_content s0 n) else get_signed_byte2 (reg_content s0 m)) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n24 (if zeq ((cpsr st)[n19]) 1 then get_signed_byte3 (reg_content s0 n) else get_signed_byte3 (reg_content s0 m)) (reg_content st d)) ]).

(* A4.1.67 SETEND *)
Definition SETEND_step (E : bool) : semfun _ := <s0>
  set_cpsr (set_bit n9 E (cpsr s0)).

(* A4.1.68 SHADD16 *)
Definition SHADD16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*sum*) (add (get_signed_half0 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n0 ((get_loc n0 (*sum*) loc)[n16#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_signed_half1 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n16 ((get_loc n0 (*sum*) loc)[n16#n1]) (reg_content st d)) ]).

(* A4.1.69 SHADD8 *)
Definition SHADD8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*sum*) (add (get_signed_byte0 (reg_content s0 n)) (get_signed_byte0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n7 n0 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_signed_byte1 (reg_content s0 n)) (get_signed_byte1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n8 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_signed_byte2 (reg_content s0 n)) (get_signed_byte2 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n23 n16 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_signed_byte3 (reg_content s0 n)) (get_signed_byte3 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n24 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d)) ]).

(* A4.1.70 SHADDSUBX *)
Definition SHADDSUBX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let sum := add (get_signed_half1 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (sum[n16#n1]) (reg_content st d))
      ; let diff := sub (get_signed_half0 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (diff[n16#n1]) (reg_content st d)) ]]]).

(* A4.1.71 SHSUB16 *)
Definition SHSUB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*diff*) (sub (get_signed_half0 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n0 ((get_loc n0 (*diff*) loc)[n16#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_signed_half1 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n16 ((get_loc n0 (*diff*) loc)[n16#n1]) (reg_content st d)) ]).

(* A4.1.72 SHSUB8 *)
Definition SHSUB8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*diff*) (sub (get_signed_byte0 (reg_content s0 n)) (get_signed_byte0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n7 n0 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_signed_byte1 (reg_content s0 n)) (get_signed_byte1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n8 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_signed_byte2 (reg_content s0 n)) (get_signed_byte2 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n23 n16 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_signed_byte3 (reg_content s0 n)) (get_signed_byte3 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n24 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d)) ]).

(* A4.1.73 SHSUBADDX *)
Definition SHSUBADDX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let diff := sub (get_signed_half1 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (diff[n16#n1]) (reg_content st d))
      ; let sum := add (get_signed_half0 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (sum[n16#n1]) (reg_content st d)) ]]]).

(* A4.1.74 SMLA<x><y> *)
Definition SMLAxy_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) (x : bool) (y : bool) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand1 := if zeq x 0 then SignExtend16 (get_signed_half0 (reg_content s0 m)) else SignExtend16 (get_signed_half1 (reg_content s0 m)) in
    let operand2 := if zeq y 0 then SignExtend16 (get_signed_half0 (reg_content s0 s)) else SignExtend16 (get_signed_half1 (reg_content s0 s)) in
    [ <st> set_reg d (add (mul operand1 operand2) (reg_content s0 n))
      ; if_then (OverflowFrom_add2 (mul operand1 operand2) (reg_content s0 n))
         (<st> set_cpsr_bit Qbit (repr 1)) ]]).

(* A4.1.75 SMLAD *)
Definition SMLAD_step (X : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := if zeq X 1 then Rotate_Right (reg_content s0 s) (repr 16) else reg_content s0 s in
    let product1 := mul (get_signed_half0 (reg_content s0 m)) (get_signed_half0 operand2) in
    let product2 := mul (get_signed_half1 (reg_content s0 m)) (get_signed_half1 operand2) in
    [ <st> set_reg d (add (add (reg_content s0 n) product1) product2)
      ; if_then (OverflowFrom_add3 (reg_content s0 n) product1 product2)
         (<st> set_cpsr_bit Qbit (repr 1)) ]]).

(* A4.1.76 SMLAL *)
Definition SMLAL_step (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ set_reg dLo (add (bits_of_signed_mul64 (reg_content s0 m) (reg_content s0 s) n31 n0) (reg_content s0 dLo))
    ; <st> set_reg dHi (add (add (bits_of_signed_mul64 (reg_content s0 m) (reg_content s0 s) n63 n32) (reg_content st dHi)) (CarryFrom_add2 (bits_of_signed_mul64 (reg_content s0 m) (reg_content s0 s) n31 n0) (reg_content s0 dLo)))
    ; if_then (zeq S 1)
         ([ <st> set_cpsr_bit Nbit ((reg_content st dHi)[n31])
         ; <st> set_cpsr_bit Zbit (if andb (zeq (reg_content st dHi) 0) (zeq (reg_content s0 dLo) 0) then repr 1 else repr 0) ]) ]).

(* A4.1.77 SMLAL<x><y> *)
Definition SMLALxy_step (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) (x : bool) (y : bool) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand1 := if zeq x 0 then SignExtend16 (get_signed_half0 (reg_content s0 m)) else SignExtend16 (get_signed_half1 (reg_content s0 m)) in
    let operand2 := if zeq y 0 then SignExtend16 (get_signed_half0 (reg_content s0 s)) else SignExtend16 (get_signed_half1 (reg_content s0 s)) in
    [ set_reg dLo (add (reg_content s0 dLo) (mul operand1 operand2))
      ; <st> set_reg dHi (add (add (reg_content st dHi) (if lt_0 (mul operand1 operand2) then repr (Zpos 4294967295) else repr 0)) (CarryFrom_add2 (reg_content s0 dLo) (mul operand1 operand2))) ]]).

(* A4.1.78 SMLALD *)
Definition SMLALD_step (X : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> let operand2 := if zeq X 1 then Rotate_Right (reg_content s0 s) (repr 16) else reg_content s0 s in
    let accvalue := or64 (Logical_Shift_Left64 ((*ZeroExtend*)(reg_content st dHi)) (repr 32)) ((*ZeroExtend*)(reg_content s0 dLo)) in
    let product1 := mul (get_signed_half0 (reg_content s0 m)) (get_signed_half0 operand2) in
    let product2 := mul (get_signed_half1 (reg_content s0 m)) (get_signed_half1 operand2) in
    let result := add64 (add64 accvalue product1) product2 in
    [ set_reg dLo (get_lo result)
      ; <st> set_reg dHi (get_hi result) ]]).

(* A4.1.79 SMLAW<y> *)
Definition SMLAWy_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) (y : bool) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := if zeq y 0 then SignExtend16 (get_signed_half0 (reg_content s0 s)) else SignExtend16 (get_signed_half1 (reg_content s0 s)) in
    [ <st> set_reg d (add (bits_of_signed_mul64 (reg_content s0 m) operand2 n47 n16) (reg_content s0 n))
      ; if_then (OverflowFrom_add2 (bits_of_signed_mul64 (reg_content s0 m) operand2 n47 n16) (reg_content s0 n))
         (<st> set_cpsr_bit Qbit (repr 1)) ]]).

(* A4.1.80 SMLSD *)
Definition SMLSD_step (X : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := if zeq X 1 then Rotate_Right (reg_content s0 s) (repr 16) else reg_content s0 s in
    let product1 := mul (get_signed_half0 (reg_content s0 m)) (get_signed_half0 operand2) in
    let product2 := mul (get_signed_half1 (reg_content s0 m)) (get_signed_half1 operand2) in
    let diffofproducts := sub product1 product2 in
    [ <st> set_reg d (add (reg_content s0 n) diffofproducts)
      ; if_then (OverflowFrom_add2 (reg_content s0 n) diffofproducts)
         (<st> set_cpsr_bit Qbit (repr 1)) ]]).

(* A4.1.81 SMLSLD *)
Definition SMLSLD_step (X : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> let operand2 := if zeq X 1 then Rotate_Right (reg_content s0 s) (repr 16) else reg_content s0 s in
    let accvalue := or64 (Logical_Shift_Left64 ((*ZeroExtend*)(reg_content st dHi)) (repr 32)) ((*ZeroExtend*)(reg_content s0 dLo)) in
    let product1 := mul (get_signed_half0 (reg_content s0 m)) (get_signed_half0 operand2) in
    let product2 := mul (get_signed_half1 (reg_content s0 m)) (get_signed_half1 operand2) in
    let result := sub64 (add64 accvalue product1) product2 in
    [ set_reg dLo (get_lo result)
      ; <st> set_reg dHi (get_hi result) ]]).

(* A4.1.82 SMMLA *)
Definition SMMLA_step (R : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let value := signed_mul64 (reg_content s0 m) (reg_content s0 s) in
    [ If (zeq R 1)
       then         (<st> set_reg d (get_hi (add64 (add64 (Logical_Shift_Left64 (reg_content s0 n) (repr 32)) value) (repr (Zpos 2147483648)))))
       else         (<st> set_reg d (get_hi (add64 (Logical_Shift_Left64 (reg_content s0 n) (repr 32)) value))) ]]).

(* A4.1.83 SMMLS *)
Definition SMMLS_step (R : bool) (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let value := signed_mul64 (reg_content s0 m) (reg_content s0 s) in
    [ If (zeq R 1)
       then         (<st> set_reg d (get_hi (add64 (sub64 (Logical_Shift_Left64 (reg_content s0 n) (repr 32)) value) (repr (Zpos 2147483648)))))
       else         (<st> set_reg d (get_hi (sub64 (Logical_Shift_Left64 (reg_content s0 n) (repr 32)) value))) ]]).

(* A4.1.84 SMMUL *)
Definition SMMUL_step (R : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let value := if zeq R 1 then add64 (signed_mul64 (reg_content s0 m) (reg_content s0 s)) (repr (Zpos 2147483648)) else signed_mul64 (reg_content s0 m) (reg_content s0 s) in
    [ <st> set_reg d (get_hi value) ]]).

(* A4.1.85 SMUAD *)
Definition SMUAD_step (X : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := if zeq X 1 then Rotate_Right (reg_content s0 s) (repr 16) else reg_content s0 s in
    let product1 := mul (get_signed_half0 (reg_content s0 m)) (get_signed_half0 operand2) in
    let product2 := mul (get_signed_half1 (reg_content s0 m)) (get_signed_half1 operand2) in
    [ <st> set_reg d (add product1 product2)
      ; if_then (OverflowFrom_add2 product1 product2)
         (<st> set_cpsr_bit Qbit (repr 1)) ]]).

(* A4.1.86 SMUL<x><y> *)
Definition SMULxy_step (cond : opcode) (d : regnum) (m : regnum) (s : regnum) (x : bool) (y : bool) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand1 := if zeq x 0 then SignExtend16 (get_signed_half0 (reg_content s0 m)) else SignExtend16 (get_signed_half1 (reg_content s0 m)) in
    let operand2 := if zeq y 0 then SignExtend16 (get_signed_half0 (reg_content s0 s)) else SignExtend16 (get_signed_half1 (reg_content s0 s)) in
    [ <st> set_reg d (mul operand1 operand2) ]]).

(* A4.1.87 SMULL *)
Definition SMULL_step (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg dHi (bits_of_signed_mul64 (reg_content s0 m) (reg_content s0 s) n63 n32)
    ; set_reg dLo (bits_of_signed_mul64 (reg_content s0 m) (reg_content s0 s) n31 n0)
    ; if_then (zeq S 1)
         ([ <st> set_cpsr_bit Nbit ((reg_content st dHi)[n31])
         ; <st> set_cpsr_bit Zbit (if andb (zeq (reg_content st dHi) 0) (zeq (reg_content s0 dLo) 0) then repr 1 else repr 0) ]) ]).

(* A4.1.88 SMULW<y> *)
Definition SMULWy_step (cond : opcode) (d : regnum) (m : regnum) (s : regnum) (y : bool) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := if zeq y 0 then SignExtend16 (get_signed_half0 (reg_content s0 s)) else SignExtend16 (get_signed_half1 (reg_content s0 s)) in
    [ <st> set_reg d (bits_of_signed_mul64 (reg_content s0 m) operand2 n47 n16) ]]).

(* A4.1.89 SMUSD *)
Definition SMUSD_step (X : bool) (cond : opcode) (d : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := if zeq X 1 then Rotate_Right (reg_content s0 s) (repr 16) else reg_content s0 s in
    let product1 := mul (get_signed_half0 (reg_content s0 m)) (get_signed_half0 operand2) in
    let product2 := mul (get_signed_half1 (reg_content s0 m)) (get_signed_half1 operand2) in
    [ <st> set_reg d (sub product1 product2) ]]).

(* A4.1.90 SRS *)
Definition SRS_step (start_address : word) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  let address := start_address in
  [ <st> write address size_Word (reg_content st LR)
    ; <st> if_then (Shared st address)
       ([ <st> update_loc n0 (*physical_address*) (TLB st address)
       ; <.loc.> ClearExclusiveByAddress (get_loc n0 (*physical_address*) loc) processor_id n4 ])
    ; <st> if_CurrentModeHasSPSR (fun em =>
       ([ <st> write (add address (repr 4)) size_Word (spsr st em)
       ; <st> if_then (Shared st (add address (repr 4)))
            ([ <st> update_loc n0 (*physical_address*) (TLB st (add address (repr 4)))
            ; <.loc.> ClearExclusiveByAddress (get_loc n0 (*physical_address*) loc) processor_id n4 ]) ])) ]].

(* A4.1.91 SSAT *)
Definition SSAT_step (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word) (shift : bool) (shift_imm : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand := if zeq shift 1 then if zeq shift_imm 0 then get_lo (Arithmetic_Shift_Right (reg_content s0 m) (repr 32)) else get_lo (Arithmetic_Shift_Right (reg_content s0 m) shift_imm) else get_lo (Logical_Shift_Left (reg_content s0 m) shift_imm) in
    [ <st> set_reg d (SignedSat operand (nat_of_Z (add sat_imm (repr 1))))
      ; if_then (SignedDoesSat operand (nat_of_Z (add sat_imm (repr 1))))
         (<st> set_cpsr_bit Qbit (repr 1)) ]]).

(* A4.1.92 SSAT16 *)
Definition SSAT16_step (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (SignedSat (get_signed_half0 (reg_content s0 m)) (nat_of_Z (add sat_imm (repr 1)))) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (SignedSat (get_signed_half1 (reg_content s0 m)) (nat_of_Z (add sat_imm (repr 1)))) (reg_content st d))
    ; if_then (orb (SignedDoesSat (get_signed_half0 (reg_content s0 m)) (nat_of_Z (add sat_imm (repr 1)))) (SignedDoesSat (get_signed_half1 (reg_content s0 m)) (nat_of_Z (add sat_imm (repr 1)))))
         (<st> set_cpsr_bit Qbit (repr 1)) ]).

(* A4.1.93 SSUB16 *)
Definition SSUB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*diff*) (sub (get_signed_half0 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n0 (get_signed_half0 (get_loc n0 (*diff*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bits n17 n16 (if ge_0 (get_loc n0 (*diff*) loc) then repr (Zpos 1~1) else repr 0) (cpsr st))
    ; update_loc n0 (*diff*) (sub (get_signed_half1 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n16 (get_signed_half0 (get_loc n0 (*diff*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bits n19 n18 (if ge_0 (get_loc n0 (*diff*) loc) then repr (Zpos 1~1) else repr 0) (cpsr st)) ]).

(* A4.1.94 SSUB8 *)
Definition SSUB8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*diff*) (sub (get_signed_byte0 (reg_content s0 n)) (get_signed_byte0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n7 n0 (get_signed_byte0 (get_loc n0 (*diff*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n16 (if ge_0 (get_loc n0 (*diff*) loc) then repr 1 else repr 0) (cpsr st))
    ; update_loc n0 (*diff*) (sub (get_signed_byte1 (reg_content s0 n)) (get_signed_byte1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n8 (get_signed_byte0 (get_loc n0 (*diff*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n17 (if ge_0 (get_loc n0 (*diff*) loc) then repr 1 else repr 0) (cpsr st))
    ; update_loc n0 (*diff*) (sub (get_signed_byte2 (reg_content s0 n)) (get_signed_byte2 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n23 n16 (get_signed_byte0 (get_loc n0 (*diff*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n18 (if ge_0 (get_loc n0 (*diff*) loc) then repr 1 else repr 0) (cpsr st))
    ; update_loc n0 (*diff*) (sub (get_signed_byte3 (reg_content s0 n)) (get_signed_byte3 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n24 (get_signed_byte0 (get_loc n0 (*diff*) loc)) (reg_content st d))
    ; <:loc st:> set_cpsr (set_bit n19 (if ge_0 (get_loc n0 (*diff*) loc) then repr 1 else repr 0) (cpsr st)) ]).

(* A4.1.95 SSUBADDX *)
Definition SSUBADDX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let diff := sub (get_signed_half1 (reg_content s0 n)) (get_signed_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (get_signed_half0 diff) (reg_content st d))
      ; <st> set_cpsr (set_bits n19 n18 (if ge_0 diff then repr (Zpos 1~1) else repr 0) (cpsr st))
      ; let sum := add (get_signed_half0 (reg_content s0 n)) (get_signed_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (get_signed_half0 sum) (reg_content st d))
        ; <st> set_cpsr (set_bits n17 n16 (if ge_0 sum then repr (Zpos 1~1) else repr 0) (cpsr st)) ]]]).

(* A4.1.96 STC *)
Definition STC_step (cond : opcode) (cp_num : word) (start_address : word) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ update_loc n1 (*address*) start_address
       ; <:loc st:> write (get_loc n1 (*address*) loc) size_Word ((*todo: value from Coprocessor[cp_num]*) (repr 0))
       ; <:loc st:> if_then (Shared st (get_loc n1 (*address*) loc))
            ([ <:loc st:> update_loc n0 (*physical_address*) (TLB st (get_loc n1 (*address*) loc))
            ; <.loc.> ClearExclusiveByAddress (get_loc n0 (*physical_address*) loc) processor_id n4 ])
       ; <:loc st:> @todo unit While (* while NotFinished(Coprocessor[cp_num]) do
    begin
    address = address + 4;
    Memory[address,4] = value from Coprocessor[cp_num];
    if Shared(address) then
        begin
        physical_address = TLB(address);
        ClearExclusiveByAddress(physical_address, processor_id, 4);
        end
    end *) ]) ]].

(* A4.1.97 STM (1) *)
Definition STM1_step (cond : opcode) (register_list : word) (start_address : word) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ update_loc n0 (*address*) start_address
       ; loop 0 n15 (fun i => 
            if_then (zeq (register_list[i]) 1)
              ([ <:loc st:> write (get_loc n0 (*address*) loc) size_Word (reg_content st i)
              ; <.loc.> update_loc n0 (*address*) (add (get_loc n0 (*address*) loc) (repr 4))
              ; <:loc st:> if_then (Shared st (get_loc n0 (*address*) loc))
                   ([ <:loc st:> let physical_address := TLB st (get_loc n0 (*address*) loc) in
                   [ ClearExclusiveByAddress physical_address processor_id n4 ]]) ])) ]) ]].

(* A4.1.98 STM (2) *)
Definition STM2_step (cond : opcode) (register_list : word) (start_address : word) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ update_loc n0 (*address*) start_address
       ; loop 0 n15 (fun i => 
            if_then (zeq (register_list[i]) 1)
              ([ <:loc st:> write (get_loc n0 (*address*) loc) size_Word (reg_content_mode st usr i)
              ; <.loc.> update_loc n0 (*address*) (add (get_loc n0 (*address*) loc) (repr 4))
              ; <:loc st:> if_then (Shared st (get_loc n0 (*address*) loc))
                   ([ <:loc st:> let physical_address := TLB st (get_loc n0 (*address*) loc) in
                   [ ClearExclusiveByAddress physical_address processor_id n4 ]]) ])) ]) ]].

(* A4.1.99 STR *)
Definition STR_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ <st> write address size_Word (reg_content st d)
       ; <st> if_then (Shared st address)
            ([ <st> let physical_address := TLB st address in
            [ ClearExclusiveByAddress physical_address processor_id n4 ]]) ]) ]].

(* A4.1.100 STRB *)
Definition STRB_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ <st> write address size_Byte (get_signed_byte0 (reg_content st d))
       ; <st> if_then (Shared st address)
            ([ <st> let physical_address := TLB st address in
            [ ClearExclusiveByAddress physical_address processor_id n1 ]]) ]) ]].

(* A4.1.101 STRBT *)
Definition STRBT_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ <st> write address size_Byte (get_signed_byte0 (reg_content st d))
       ; <st> if_then (Shared st address)
            ([ <st> let physical_address := TLB st address in
            [ ClearExclusiveByAddress physical_address processor_id n1 ]]) ]) ]].

(* A4.1.102 STRD *)
Definition STRD_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ <st> If (andb (andb (andb (is_even d) (zne d (repr 14))) (zeq (address[n1#n0]) (repr (Z0)))) (orb (zeq ((CP15_reg1 st)[Ubit]) 1) (zeq (address[n2]) 0)))
          then            ([ <st> write address size_Word (reg_content st d)
            ; <st> write (add address (repr 4)) size_Word (reg_content st (mk_regnum (add d (repr 1)))) ])
          else            (unpredictable EmptyMessage)
       ; <st> if_then (Shared st address)
            ([ <st> update_loc n0 (*physical_address*) (TLB st address)
            ; <.loc.> ClearExclusiveByAddress (get_loc n0 (*physical_address*) loc) processor_id n4 ])
       ; <st> if_then (Shared st (add address (repr 4)))
            ([ <st> update_loc n0 (*physical_address*) (TLB st (add address (repr 4)))
            ; <.loc.> ClearExclusiveByAddress (get_loc n0 (*physical_address*) loc) processor_id n4 ]) ]) ]].

(* A4.1.103 STREX *)
Definition STREX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> let processor_id := ExecutingProcessor st in
    let physical_address := TLB st (reg_content s0 n) in
    [ <st> If (IsExclusiveLocal st physical_address processor_id n4)
       then         (<st> If (zeq (Shared st (reg_content s0 n)) 1)
         then           (<st> If (IsExclusiveGlobal st physical_address processor_id n4)
           then             ([ <st> write (reg_content s0 n) size_Word (reg_content s0 m)
             ; <st> set_reg d (repr 0)
             ; ClearExclusiveByAddress physical_address processor_id n4 ])
           else             (<st> set_reg d (repr 1)))
         else           ([ <st> write (reg_content s0 n) size_Word (reg_content s0 m)
           ; <st> set_reg d (repr 0) ]))
       else         (<st> set_reg d (repr 1))
      ; ClearExclusiveLocal processor_id ]]).

(* A4.1.104 STRH *)
Definition STRH_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ <st> If (zeq ((CP15_reg1 st)[Ubit]) 0)
          then            (If (zeq (address[n0]) (repr (Z0)))
            then              (<st> write address size_Half (get_signed_half0 (reg_content st d)))
            else              (unpredictable EmptyMessage))
          else            (<st> write address size_Half (get_signed_half0 (reg_content st d)))
       ; <st> if_then (Shared st address)
            ([ <st> let physical_address := TLB st address in
            [ ClearExclusiveByAddress physical_address processor_id n2 ]]) ]) ]].

(* A4.1.105 STRT *)
Definition STRT_step (address : word) (cond : opcode) (d : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ <st> write address size_Word (reg_content st d)
       ; <st> if_then (Shared st address)
            ([ <st> let physical_address := TLB st address in
            [ ClearExclusiveByAddress physical_address processor_id n4 ]]) ]) ]].

(* A4.1.106 SUB *)
Definition SUB_step (S : bool) (cond : opcode) (d : regnum) (n : regnum) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (sub (reg_content s0 n) shifter_operand)
    ; If (andb (zeq S 1) (zeq d 15))
       then         (<st> if_CurrentModeHasSPSR (fun em =>
           (<st> set_cpsr (spsr st em))))
       else         (if_then (zeq S 1)
           ([ <st> set_cpsr_bit Nbit ((reg_content st d)[n31])
           ; <st> set_cpsr_bit Zbit (if zeq (reg_content st d) 0 then repr 1 else repr 0)
           ; <st> set_cpsr_bit Cbit (negb (BorrowFrom_sub2 (reg_content s0 n) shifter_operand))
           ; <st> set_cpsr_bit Vbit (OverflowFrom_sub2 (reg_content s0 n) shifter_operand) ])) ]).

(* A4.1.107 SWI *)
Definition SWI_step (cond : opcode) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg_mode (exn svc) LR (address_of_next_instruction st)
    ; <st> set_spsr svc (cpsr st)
    ; <st> set_cpsr (set_bits n4 n0 (repr (Zpos 1~0~0~1~1)) (cpsr st))
    ; <st> set_cpsr (set_bit n5 (repr 0) (cpsr st))
    ; <st> set_cpsr (set_bit n7 (repr 1) (cpsr st))
    ; <st> set_cpsr (set_bit n9 ((CP15_reg1 st)[EEbit]) (cpsr st))
    ; <st> If (high_vectors_configured st)
       then         (<st> set_reg PC (repr (Zpos 4294901768)))
       else         (<st> set_reg PC (repr (Zpos 8))) ]).

(* A4.1.108 SWP *)
Definition SWP_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ let address := reg_content s0 n in
       [ <:loc st:> If (zeq ((CP15_reg1 st)[Ubit]) 0)
          then            ([ <st> update_loc n0 (*temp*) (Rotate_Right (read st address size_Word) (mul (repr 8) (address[n1#n0])))
            ; <st> write address size_Word (reg_content s0 m)
            ; <:loc st:> set_reg d (get_loc n0 (*temp*) loc) ])
          else            ([ <st> update_loc n0 (*temp*) (read st address size_Word)
            ; <st> write address size_Word (reg_content s0 m)
            ; <:loc st:> set_reg d (get_loc n0 (*temp*) loc) ])
         ; <st> if_then (Shared st address)
            ([ <st> let physical_address := TLB st address in
            [ ClearExclusiveByAddress physical_address processor_id n4 ]]) ]]) ]].

(* A4.1.109 SWPB *)
Definition SWPB_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  [ <st> let processor_id := ExecutingProcessor st in
  [ if_then (ConditionPassed s0 cond)
       ([ <st> let address := reg_content s0 n in
       let temp := read st address size_Byte in
       [ <st> write address size_Byte (get_signed_byte0 (reg_content s0 m))
         ; <st> set_reg d temp
         ; <st> if_then (Shared st address)
            ([ <st> let physical_address := TLB st address in
            [ ClearExclusiveByAddress physical_address processor_id n1 ]]) ]]) ]].

(* A4.1.110 SXTAB *)
Definition SXTAB_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := Rotate_Right (reg_content s0 m) (mul (repr 8) rotate) in
    [ <st> set_reg d (add (reg_content s0 n) (SignExtend8 (get_signed_byte0 operand2))) ]]).

(* A4.1.111 SXTAB16 *)
Definition SXTAB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := Rotate_Right (reg_content s0 m) (mul (repr 8) rotate) in
    [ <st> set_reg d (set_bits n15 n0 (add (get_signed_half0 (reg_content s0 n)) (SignExtend8 (get_signed_byte0 operand2))) (reg_content st d))
      ; <st> set_reg d (set_bits n31 n16 (add (get_signed_half1 (reg_content s0 n)) (SignExtend8 (get_signed_byte2 operand2))) (reg_content st d)) ]]).

(* A4.1.112 SXTAH *)
Definition SXTAH_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := Rotate_Right (reg_content s0 m) (mul (repr 8) rotate) in
    [ <st> set_reg d (add (reg_content s0 n) (SignExtend16 (get_signed_half0 operand2))) ]]).

(* A4.1.113 SXTB *)
Definition SXTB_step (cond : opcode) (d : regnum) (m : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := Rotate_Right (reg_content s0 m) (mul (repr 8) rotate) in
    [ <st> set_reg d (set_bits n31 n0 (SignExtend8 (get_signed_byte0 operand2)) (reg_content st d)) ]]).

(* A4.1.114 SXTB16 *)
Definition SXTB16_step (cond : opcode) (d : regnum) (m : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := Rotate_Right (reg_content s0 m) (mul (repr 8) rotate) in
    [ <st> set_reg d (set_bits n15 n0 (SignExtend8 (get_signed_byte0 operand2)) (reg_content st d))
      ; <st> set_reg d (set_bits n31 n16 (SignExtend8 (get_signed_byte2 operand2)) (reg_content st d)) ]]).

(* A4.1.115 SXTH *)
Definition SXTH_step (cond : opcode) (d : regnum) (m : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := Rotate_Right (reg_content s0 m) (mul (repr 8) rotate) in
    [ <st> set_reg d (set_bits n31 n0 (SignExtend16 (get_signed_half0 operand2)) (reg_content st d)) ]]).

(* A4.1.116 TEQ *)
Definition TEQ_step (cond : opcode) (n : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let alu_out := xor (reg_content s0 n) shifter_operand in
    [ <st> set_cpsr_bit Nbit (alu_out[n31])
      ; <st> set_cpsr_bit Zbit (if zeq alu_out 0 then repr 1 else repr 0)
      ; <st> set_cpsr_bit Cbit shifter_carry_out ]]).

(* A4.1.117 TST *)
Definition TST_step (cond : opcode) (n : regnum) (shifter_carry_out : word) (shifter_operand : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let alu_out := and (reg_content s0 n) shifter_operand in
    [ <st> set_cpsr_bit Nbit (alu_out[n31])
      ; <st> set_cpsr_bit Zbit (if zeq alu_out 0 then repr 1 else repr 0)
      ; <st> set_cpsr_bit Cbit shifter_carry_out ]]).

(* A4.1.118 UADD16 *)
Definition UADD16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (add (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bits n17 n16 (if zeq (CarryFrom16_add2 (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m))) 1 then repr (Zpos 1~1) else repr 0) (cpsr st))
    ; <st> set_reg d (set_bits n31 n16 (add (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bits n19 n18 (if zeq (CarryFrom16_add2 (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m))) 1 then repr (Zpos 1~1) else repr 0) (cpsr st)) ]).

(* A4.1.119 UADD8 *)
Definition UADD8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n7 n0 (add (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n16 (CarryFrom8_add2 (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m))) (cpsr st))
    ; <st> set_reg d (set_bits n15 n8 (add (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n17 (CarryFrom8_add2 (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m))) (cpsr st))
    ; <st> set_reg d (set_bits n23 n16 (add (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n18 (CarryFrom8_add2 (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m))) (cpsr st))
    ; <st> set_reg d (set_bits n31 n24 (add (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n19 (CarryFrom8_add2 (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m))) (cpsr st)) ]).

(* A4.1.120 UADDSUBX *)
Definition UADDSUBX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let sum := add (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (get_half0 sum) (reg_content st d))
      ; <st> set_cpsr (set_bits n19 n18 (if CarryFrom16_add2 (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m)) then repr (Zpos 1~1) else repr 0) (cpsr st))
      ; let diff := sub (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (get_half0 diff) (reg_content st d))
        ; <st> set_cpsr (set_bits n17 n16 (if BorrowFrom_sub2 (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m)) then repr (Zpos 1~1) else repr 0) (cpsr st)) ]]]).

(* A4.1.121 UHADD16 *)
Definition UHADD16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*sum*) (add (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n0 ((get_loc n0 (*sum*) loc)[n16#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n16 ((get_loc n0 (*sum*) loc)[n16#n1]) (reg_content st d)) ]).

(* A4.1.122 UHADD8 *)
Definition UHADD8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*sum*) (add (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n7 n0 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n8 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n23 n16 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*sum*) (add (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n24 ((get_loc n0 (*sum*) loc)[n8#n1]) (reg_content st d)) ]).

(* A4.1.123 UHADDSUBX *)
Definition UHADDSUBX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let sum := add (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (sum[n16#n1]) (reg_content st d))
      ; let diff := sub (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (diff[n16#n1]) (reg_content st d)) ]]]).

(* A4.1.124 UHSUB16 *)
Definition UHSUB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*diff*) (sub (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n0 ((get_loc n0 (*diff*) loc)[n16#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n16 ((get_loc n0 (*diff*) loc)[n16#n1]) (reg_content st d)) ]).

(* A4.1.125 UHSUB8 *)
Definition UHSUB8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ update_loc n0 (*diff*) (sub (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n7 n0 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n15 n8 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n23 n16 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d))
    ; update_loc n0 (*diff*) (sub (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m)))
    ; <:loc st:> set_reg d (set_bits n31 n24 ((get_loc n0 (*diff*) loc)[n8#n1]) (reg_content st d)) ]).

(* A4.1.126 UHSUBADDX *)
Definition UHSUBADDX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let diff := sub (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (diff[n16#n1]) (reg_content st d))
      ; let sum := add (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (sum[n16#n1]) (reg_content st d)) ]]]).

(* A4.1.127 UMAAL *)
Definition UMAAL_step (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> let result := add64 (add64 (mul64 (reg_content s0 m) (reg_content s0 s)) (reg_content s0 dLo)) (reg_content st dHi) in
    [ set_reg dLo (get_lo result)
      ; <st> set_reg dHi (get_hi result) ]]).

(* A4.1.128 UMLAL *)
Definition UMLAL_step (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ set_reg dLo (add (bits_of_unsigned_mul64 (reg_content s0 m) (reg_content s0 s) n31 n0) (reg_content s0 dLo))
    ; <st> set_reg dHi (add (add (bits_of_unsigned_mul64 (reg_content s0 m) (reg_content s0 s) n63 n32) (reg_content st dHi)) (CarryFrom_add2 (bits_of_unsigned_mul64 (reg_content s0 m) (reg_content s0 s) n31 n0) (reg_content s0 dLo)))
    ; if_then (zeq S 1)
         ([ <st> set_cpsr_bit Nbit ((reg_content st dHi)[n31])
         ; <st> set_cpsr_bit Zbit (if andb (zeq (reg_content st dHi) 0) (zeq (reg_content s0 dLo) 0) then repr 1 else repr 0) ]) ]).

(* A4.1.129 UMULL *)
Definition UMULL_step (S : bool) (cond : opcode) (dHi : regnum) (dLo : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg dHi (bits_of_unsigned_mul64 (reg_content s0 m) (reg_content s0 s) n63 n32)
    ; set_reg dLo (bits_of_unsigned_mul64 (reg_content s0 m) (reg_content s0 s) n31 n0)
    ; if_then (zeq S 1)
         ([ <st> set_cpsr_bit Nbit ((reg_content st dHi)[n31])
         ; <st> set_cpsr_bit Zbit (if andb (zeq (reg_content st dHi) 0) (zeq (reg_content s0 dLo) 0) then repr 1 else repr 0) ]) ]).

(* A4.1.130 UQADD16 *)
Definition UQADD16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (UnsignedSat (add (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (UnsignedSat (add (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.131 UQADD8 *)
Definition UQADD8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n7 n0 (UnsignedSat (add (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n8 (UnsignedSat (add (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n23 n16 (UnsignedSat (add (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n24 (UnsignedSat (add (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m))) n8) (reg_content st d)) ]).

(* A4.1.132 UQADDSUBX *)
Definition UQADDSUBX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (UnsignedSat (sub (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (UnsignedSat (add (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.133 UQSUB16 *)
Definition UQSUB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (UnsignedSat (sub (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (UnsignedSat (sub (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.134 UQSUB8 *)
Definition UQSUB8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n7 n0 (UnsignedSat (sub (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n8 (UnsignedSat (sub (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n23 n16 (UnsignedSat (sub (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m))) n8) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n24 (UnsignedSat (sub (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m))) n8) (reg_content st d)) ]).

(* A4.1.135 UQSUBADDX *)
Definition UQSUBADDX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n31 n16 (UnsignedSat (sub (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m))) n16) (reg_content st d))
    ; <st> set_reg d (set_bits n15 n0 (UnsignedSat (add (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m))) n16) (reg_content st d)) ]).

(* A4.1.136 USAD8 *)
Definition USAD8_step (cond : opcode) (d : regnum) (m : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let diff1 := if zlt (get_byte0 (reg_content s0 m)) (get_byte0 (reg_content s0 s)) then sub (get_byte0 (reg_content s0 s)) (get_byte0 (reg_content s0 m)) else sub (get_byte0 (reg_content s0 m)) (get_byte0 (reg_content s0 s)) in
    let diff2 := if zlt (get_byte1 (reg_content s0 m)) (get_byte1 (reg_content s0 s)) then sub (get_byte1 (reg_content s0 s)) (get_byte1 (reg_content s0 m)) else sub (get_byte1 (reg_content s0 m)) (get_byte1 (reg_content s0 s)) in
    let diff3 := if zlt (get_byte2 (reg_content s0 m)) (get_byte2 (reg_content s0 s)) then sub (get_byte2 (reg_content s0 s)) (get_byte2 (reg_content s0 m)) else sub (get_byte2 (reg_content s0 m)) (get_byte2 (reg_content s0 s)) in
    let diff4 := if zlt (get_byte3 (reg_content s0 m)) (get_byte3 (reg_content s0 s)) then sub (get_byte3 (reg_content s0 s)) (get_byte3 (reg_content s0 m)) else sub (get_byte3 (reg_content s0 m)) (get_byte3 (reg_content s0 s)) in
    [ <st> set_reg d (add (add (add ((*ZeroExtend*)diff1) ((*ZeroExtend*)diff2)) ((*ZeroExtend*)diff3)) ((*ZeroExtend*)diff4)) ]]).

(* A4.1.137 USADA8 *)
Definition USADA8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (s : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let diff1 := if zlt (get_byte0 (reg_content s0 m)) (get_byte0 (reg_content s0 s)) then sub (get_byte0 (reg_content s0 s)) (get_byte0 (reg_content s0 m)) else sub (get_byte0 (reg_content s0 m)) (get_byte0 (reg_content s0 s)) in
    let diff2 := if zlt (get_byte1 (reg_content s0 m)) (get_byte1 (reg_content s0 s)) then sub (get_byte1 (reg_content s0 s)) (get_byte1 (reg_content s0 m)) else sub (get_byte1 (reg_content s0 m)) (get_byte1 (reg_content s0 s)) in
    let diff3 := if zlt (get_byte2 (reg_content s0 m)) (get_byte2 (reg_content s0 s)) then sub (get_byte2 (reg_content s0 s)) (get_byte2 (reg_content s0 m)) else sub (get_byte2 (reg_content s0 m)) (get_byte2 (reg_content s0 s)) in
    let diff4 := if zlt (get_byte3 (reg_content s0 m)) (get_byte3 (reg_content s0 s)) then sub (get_byte3 (reg_content s0 s)) (get_byte3 (reg_content s0 m)) else sub (get_byte3 (reg_content s0 m)) (get_byte3 (reg_content s0 s)) in
    [ <st> set_reg d (add (add (add (add (reg_content s0 n) ((*ZeroExtend*)diff1)) ((*ZeroExtend*)diff2)) ((*ZeroExtend*)diff3)) ((*ZeroExtend*)diff4)) ]]).

(* A4.1.138 USAT *)
Definition USAT_step (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word) (shift : bool) (shift_imm : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand := if zeq shift 1 then if zeq shift_imm 0 then get_lo (Arithmetic_Shift_Right (reg_content s0 m) (repr 32)) else get_lo (Arithmetic_Shift_Right (reg_content s0 m) shift_imm) else get_lo (Logical_Shift_Left (reg_content s0 m) shift_imm) in
    [ <st> set_reg d (UnsignedSat operand (nat_of_Z sat_imm))
      ; if_then (UnsignedDoesSat operand (nat_of_Z sat_imm))
         (<st> set_cpsr_bit Qbit (repr 1)) ]]).

(* A4.1.139 USAT16 *)
Definition USAT16_step (cond : opcode) (d : regnum) (m : regnum) (sat_imm : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (UnsignedSat (get_half0 (reg_content s0 m)) (nat_of_Z sat_imm)) (reg_content st d))
    ; <st> set_reg d (set_bits n31 n16 (UnsignedSat (get_half1 (reg_content s0 m)) (nat_of_Z sat_imm)) (reg_content st d))
    ; if_then (orb (UnsignedDoesSat (get_half0 (reg_content s0 m)) (nat_of_Z sat_imm)) (UnsignedDoesSat (get_half1 (reg_content s0 m)) (nat_of_Z sat_imm)))
         (<st> set_cpsr_bit Qbit (repr 1)) ]).

(* A4.1.140 USUB16 *)
Definition USUB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n15 n0 (sub (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bits n17 n16 (if BorrowFrom_sub2 (get_half0 (reg_content s0 n)) (get_half0 (reg_content s0 m)) then repr 0 else repr (Zpos 1~1)) (cpsr st))
    ; <st> set_reg d (set_bits n31 n16 (sub (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bits n19 n18 (if BorrowFrom_sub2 (get_half1 (reg_content s0 n)) (get_half1 (reg_content s0 m)) then repr 0 else repr (Zpos 1~1)) (cpsr st)) ]).

(* A4.1.141 USUB8 *)
Definition USUB8_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ <st> set_reg d (set_bits n7 n0 (sub (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n16 (negb (BorrowFrom_sub2 (get_byte0 (reg_content s0 n)) (get_byte0 (reg_content s0 m)))) (cpsr st))
    ; <st> set_reg d (set_bits n15 n8 (sub (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n17 (negb (BorrowFrom_sub2 (get_byte1 (reg_content s0 n)) (get_byte1 (reg_content s0 m)))) (cpsr st))
    ; <st> set_reg d (set_bits n23 n16 (sub (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n18 (negb (BorrowFrom_sub2 (get_byte2 (reg_content s0 n)) (get_byte2 (reg_content s0 m)))) (cpsr st))
    ; <st> set_reg d (set_bits n31 n24 (sub (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m))) (reg_content st d))
    ; <st> set_cpsr (set_bit n19 (negb (BorrowFrom_sub2 (get_byte3 (reg_content s0 n)) (get_byte3 (reg_content s0 m)))) (cpsr st)) ]).

(* A4.1.142 USUBADDX *)
Definition USUBADDX_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let diff := sub (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m)) in
    [ <st> set_reg d (set_bits n31 n16 (get_half0 diff) (reg_content st d))
      ; <st> set_cpsr (set_bits n19 n18 (if BorrowFrom_sub2 (get_half1 (reg_content s0 n)) (get_half0 (reg_content s0 m)) then repr (Zpos 1~1) else repr 0) (cpsr st))
      ; let sum := add (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m)) in
      [ <st> set_reg d (set_bits n15 n0 (get_half0 sum) (reg_content st d))
        ; <st> set_cpsr (set_bits n17 n16 (if CarryFrom16_add2 (get_half0 (reg_content s0 n)) (get_half1 (reg_content s0 m)) then repr (Zpos 1~1) else repr 0) (cpsr st)) ]]]).

(* A4.1.143 UXTAB *)
Definition UXTAB_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := and (Rotate_Right (reg_content s0 m) (mul (repr 8) rotate)) (repr (Zpos 255)) in
    [ <st> set_reg d (add (reg_content s0 n) operand2) ]]).

(* A4.1.144 UXTAB16 *)
Definition UXTAB16_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := and (Rotate_Right (reg_content s0 m) (mul (repr 8) rotate)) (repr (Zpos 16711935)) in
    [ <st> set_reg d (set_bits n15 n0 (add (get_half0 (reg_content s0 n)) (get_half0 operand2)) (reg_content st d))
      ; <st> set_reg d (set_bits n31 n16 (add (get_half1 (reg_content s0 n)) (get_byte2 operand2)) (reg_content st d)) ]]).

(* A4.1.145 UXTAH *)
Definition UXTAH_step (cond : opcode) (d : regnum) (m : regnum) (n : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    ([ let operand2 := and (Rotate_Right (reg_content s0 m) (mul (repr 8) rotate)) (repr (Zpos 65535)) in
    [ <st> set_reg d (add (reg_content s0 n) operand2) ]]).

(* A4.1.146 UXTB *)
Definition UXTB_step (cond : opcode) (d : regnum) (m : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> set_reg d (set_bits n31 n0 (and (Rotate_Right (reg_content s0 m) (mul (repr 8) rotate)) (repr (Zpos 255))) (reg_content st d))).

(* A4.1.147 UXTB16 *)
Definition UXTB16_step (cond : opcode) (d : regnum) (m : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> set_reg d (set_bits n31 n0 (and (Rotate_Right (reg_content s0 m) (mul (repr 8) rotate)) (repr (Zpos 16711935))) (reg_content st d))).

(* A4.1.148 UXTH *)
Definition UXTH_step (cond : opcode) (d : regnum) (m : regnum) (rotate : word) : semfun _ := <s0>
  if_then (ConditionPassed s0 cond)
    (<st> set_reg d (set_bits n31 n0 (and (Rotate_Right (reg_content s0 m) (mul (repr 8) rotate)) (repr (Zpos 65535))) (reg_content st d))).

(* A5.1.3 Data processing operands - Immediate *)
Definition M1_Immediate_step (immed_8 : word) (rotate_imm : word) : semfun _ := <s0>
  let shifter_operand := Rotate_Right immed_8 (mul rotate_imm (repr 2)) in
  let shifter_carry_out := if zeq rotate_imm 0 then (cpsr s0)[Cbit] else shifter_operand[n31] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.4 Data processing operands - Register *)
Definition M1_Register_step (m : regnum) : semfun _ := <s0>
  let shifter_operand := reg_content s0 m in
  let shifter_carry_out := (cpsr s0)[Cbit] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.5 Data processing operands - Logical shift left by immediate *)
Definition M1_Logical_shift_left_by_immediate_step (m : regnum) (shift_imm : word) : semfun _ := <s0>
  let shifter_operand := if zeq shift_imm 0 then reg_content s0 m else Logical_Shift_Left (reg_content s0 m) shift_imm in
  let shifter_carry_out := if zeq shift_imm 0 then (cpsr s0)[Cbit] else (reg_content s0 m)[(nat_of_Z (sub (repr 32) shift_imm))] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.6 Data processing operands - Logical shift left by register *)
Definition M1_Logical_shift_left_by_register_step (m : regnum) (s : regnum) : semfun _ := <s0>
  let shifter_operand := if zeq (get_byte0 (reg_content s0 s)) 0 then reg_content s0 m else if zlt (get_byte0 (reg_content s0 s)) (repr 32) then Logical_Shift_Left (reg_content s0 m) (get_byte0 (reg_content s0 s)) else repr 0 in
  let shifter_carry_out := if zeq (get_byte0 (reg_content s0 s)) 0 then (cpsr s0)[Cbit] else if zlt (get_byte0 (reg_content s0 s)) (repr 32) then (reg_content s0 m)[(nat_of_Z (sub (repr 32) (get_byte0 (reg_content s0 s))))] else if zeq (get_byte0 (reg_content s0 s)) 32 then (reg_content s0 m)[n0] else repr 0 in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.7 Data processing operands - Logical shift right by immediate *)
Definition M1_Logical_shift_right_by_immediate_step (m : regnum) (shift_imm : word) : semfun _ := <s0>
  let shifter_operand := if zeq shift_imm 0 then repr 0 else Logical_Shift_Right (reg_content s0 m) shift_imm in
  let shifter_carry_out := if zeq shift_imm 0 then (reg_content s0 m)[n31] else (reg_content s0 m)[(nat_of_Z (sub shift_imm (repr 1)))] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.8 Data processing operands - Logical shift right by register *)
Definition M1_Logical_shift_right_by_register_step (m : regnum) (s : regnum) : semfun _ := <s0>
  let shifter_operand := if zeq (get_byte0 (reg_content s0 s)) 0 then reg_content s0 m else if zlt (get_byte0 (reg_content s0 s)) (repr 32) then Logical_Shift_Right (reg_content s0 m) (get_byte0 (reg_content s0 s)) else repr 0 in
  let shifter_carry_out := if zeq (get_byte0 (reg_content s0 s)) 0 then (cpsr s0)[Cbit] else if zlt (get_byte0 (reg_content s0 s)) (repr 32) then (reg_content s0 m)[(nat_of_Z (sub (get_byte0 (reg_content s0 s)) (repr 1)))] else if zeq (get_byte0 (reg_content s0 s)) 32 then (reg_content s0 m)[n31] else repr 0 in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.9 Data processing operands - Arithmetic shift right by immediate *)
Definition M1_Arithmetic_shift_right_by_immediate_step (m : regnum) (shift_imm : word) : semfun _ := <s0>
  let shifter_operand := if zeq shift_imm 0 then if zeq ((reg_content s0 m)[n31]) 0 then repr 0 else repr (Zpos 4294967295) else Arithmetic_Shift_Right (reg_content s0 m) shift_imm in
  let shifter_carry_out := if zeq shift_imm 0 then (reg_content s0 m)[n31] else (reg_content s0 m)[(nat_of_Z (sub shift_imm (repr 1)))] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.10 Data processing operands - Arithmetic shift right by register *)
Definition M1_Arithmetic_shift_right_by_register_step (m : regnum) (s : regnum) : semfun _ := <s0>
  let shifter_operand := if zeq (get_byte0 (reg_content s0 s)) 0 then reg_content s0 m else if zlt (get_byte0 (reg_content s0 s)) (repr 32) then Arithmetic_Shift_Right (reg_content s0 m) (get_byte0 (reg_content s0 s)) else if zeq ((reg_content s0 m)[n31]) 0 then repr 0 else repr (Zpos 4294967295) in
  let shifter_carry_out := if zeq (get_byte0 (reg_content s0 s)) 0 then (cpsr s0)[Cbit] else if zlt (get_byte0 (reg_content s0 s)) (repr 32) then (reg_content s0 m)[(nat_of_Z (sub (get_byte0 (reg_content s0 s)) (repr 1)))] else (reg_content s0 m)[n31] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.11 Data processing operands - Rotate right by immediate *)
Definition M1_Rotate_right_by_immediate_step (m : regnum) (shift_imm : word) : semfun _ := <s0>
  let shifter_operand := if zeq shift_imm 0 then or (Logical_Shift_Left ((cpsr s0)[Cbit]) (repr 31)) (Logical_Shift_Right (reg_content s0 m) (repr 1)) else Rotate_Right (reg_content s0 m) shift_imm in
  let shifter_carry_out := if zeq shift_imm 0 then (reg_content s0 m)[n0] else (reg_content s0 m)[(nat_of_Z (sub shift_imm (repr 1)))] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.12 Data processing operands - Rotate right by register *)
Definition M1_Rotate_right_by_register_step (m : regnum) (s : regnum) : semfun _ := <s0>
  let shifter_operand := if zeq (get_byte0 (reg_content s0 s)) 0 then reg_content s0 m else if zeq ((reg_content s0 s)[n4#n0]) 0 then reg_content s0 m else Rotate_Right (reg_content s0 m) ((reg_content s0 s)[n4#n0]) in
  let shifter_carry_out := if zeq (get_byte0 (reg_content s0 s)) 0 then (cpsr s0)[Cbit] else if zeq ((reg_content s0 s)[n4#n0]) 0 then (reg_content s0 m)[n31] else (reg_content s0 m)[(nat_of_Z (sub ((reg_content s0 s)[n4#n0]) (repr 1)))] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.1.13 Data processing operands - Rotate right with extend *)
Definition M1_Rotate_right_with_extend_step (m : regnum) : semfun _ := <s0>
  let shifter_operand := or (Logical_Shift_Left ((cpsr s0)[Cbit]) (repr 31)) (Logical_Shift_Right (reg_content s0 m) (repr 1)) in
  let shifter_carry_out := (reg_content s0 m)[n0] in
  ret_ {{ shifter_operand ; shifter_carry_out }}.

(* A5.2.2 Load and Store Word or Unsigned Byte - Immediate offset *)
Definition M2_Immediate_offset_step (U : bool) (n : regnum) (offset_12 : word) : semfun _ := <s0>
  let address := if zeq U 1 then add (reg_content s0 n) offset_12 else sub (reg_content s0 n) offset_12 in
  ret_ {{ address }}.

(* A5.2.3 Load and Store Word or Unsigned Byte - Register offset *)
Definition M2_Register_offset_step (U : bool) (m : regnum) (n : regnum) : semfun _ := <s0>
  let address := if zeq U 1 then add (reg_content s0 n) (reg_content s0 m) else sub (reg_content s0 n) (reg_content s0 m) in
  ret_ {{ address }}.

(* A5.2.4 Load and Store Word or Unsigned Byte - Scaled register offset *)
Definition M2_Scaled_register_offset_step (U : bool) (m : regnum) (n : regnum) (shift : word) (shift_imm : word) : semfun _ := <s0>
  let index :=
    match unsigned shift with
      | (Z0) => Logical_Shift_Left (reg_content s0 m) shift_imm
      | (Zpos 1) => if zeq shift_imm 0 then repr 0 else Logical_Shift_Right (reg_content s0 m) shift_imm
      | (Zpos 1~0) => if zeq shift_imm 0 then if zeq ((reg_content s0 m)[n31]) 1 then repr (Zpos 4294967295) else repr 0 else Arithmetic_Shift_Right (reg_content s0 m) shift_imm
      | (Zpos 1~1) => if zeq shift_imm 0 then or (Logical_Shift_Left ((cpsr s0)[Cbit]) (repr 31)) (Logical_Shift_Right (reg_content s0 m) (repr 1)) else Rotate_Right (reg_content s0 m) shift_imm
      | _ => repr 0
    end in
  let address := if zeq U 1 then add (reg_content s0 n) index else sub (reg_content s0 n) index in
  ret_ {{ address }}.

(* A5.2.5 Load and Store Word or Unsigned Byte - Immediate pre indexed *)
Definition M2_Immediate_pre_indexed_step (U : bool) (cond : opcode) (n : regnum) (offset_12 : word) : semfun _ := <s0>
  let address := if zeq U 1 then add (reg_content s0 n) offset_12 else sub (reg_content s0 n) offset_12 in
  do_then [ if_then (ConditionPassed s0 cond)
       (set_reg n address) ];
  ret_ {{ address }}.

(* A5.2.6 Load and Store Word or Unsigned Byte - Register pre indexed *)
Definition M2_Register_pre_indexed_step (U : bool) (cond : opcode) (m : regnum) (n : regnum) : semfun _ := <s0>
  let address := if zeq U 1 then add (reg_content s0 n) (reg_content s0 m) else sub (reg_content s0 n) (reg_content s0 m) in
  do_then [ if_then (ConditionPassed s0 cond)
       (set_reg n address) ];
  ret_ {{ address }}.

(* A5.2.7 Load and Store Word or Unsigned Byte - Scaled register pre indexed *)
Definition M2_Scaled_register_pre_indexed_step (U : bool) (cond : opcode) (m : regnum) (n : regnum) (shift : word) (shift_imm : word) : semfun _ := <s0>
  let index :=
    match unsigned shift with
      | (Z0) => Logical_Shift_Left (reg_content s0 m) shift_imm
      | (Zpos 1) => if zeq shift_imm 0 then repr 0 else Logical_Shift_Right (reg_content s0 m) shift_imm
      | (Zpos 1~0) => if zeq shift_imm 0 then if zeq ((reg_content s0 m)[n31]) 1 then repr (Zpos 4294967295) else repr 0 else Arithmetic_Shift_Right (reg_content s0 m) shift_imm
      | (Zpos 1~1) => if zeq shift_imm 0 then or (Logical_Shift_Left ((cpsr s0)[Cbit]) (repr 31)) (Logical_Shift_Right (reg_content s0 m) (repr 1)) else Rotate_Right (reg_content s0 m) shift_imm
      | _ => repr 0
    end in
  let address := if zeq U 1 then add (reg_content s0 n) index else sub (reg_content s0 n) index in
  do_then [ if_then (ConditionPassed s0 cond)
       (set_reg n address) ];
  ret_ {{ address }}.

(* A5.2.8 Load and Store Word or Unsigned Byte - Immediate post indexed *)
Definition M2_Immediate_post_indexed_step (U : bool) (cond : opcode) (n : regnum) (offset_12 : word) : semfun _ := <s0>
  let address := reg_content s0 n in
  do_then [ if_then (ConditionPassed s0 cond)
       (If (zeq U 1)
       then         (set_reg n (add (reg_content s0 n) offset_12))
       else         (set_reg n (sub (reg_content s0 n) offset_12))) ];
  ret_ {{ address }}.

(* A5.2.9 Load and Store Word or Unsigned Byte - Register post indexed *)
Definition M2_Register_post_indexed_step (U : bool) (cond : opcode) (m : regnum) (n : regnum) : semfun _ := <s0>
  let address := reg_content s0 n in
  do_then [ if_then (ConditionPassed s0 cond)
       (If (zeq U 1)
       then         (set_reg n (add (reg_content s0 n) (reg_content s0 m)))
       else         (set_reg n (sub (reg_content s0 n) (reg_content s0 m)))) ];
  ret_ {{ address }}.

(* A5.2.10 Load and Store Word or Unsigned Byte - Scaled register post indexed *)
Definition M2_Scaled_register_post_indexed_step (U : bool) (cond : opcode) (m : regnum) (n : regnum) (shift : word) (shift_imm : word) : semfun _ := <s0>
  let address := reg_content s0 n in
  let index :=
    match unsigned shift with
      | (Z0) => Logical_Shift_Left (reg_content s0 m) shift_imm
      | (Zpos 1) => if zeq shift_imm 0 then repr 0 else Logical_Shift_Right (reg_content s0 m) shift_imm
      | (Zpos 1~0) => if zeq shift_imm 0 then if zeq ((reg_content s0 m)[n31]) 1 then repr (Zpos 4294967295) else repr 0 else Arithmetic_Shift_Right (reg_content s0 m) shift_imm
      | (Zpos 1~1) => if zeq shift_imm 0 then or (Logical_Shift_Left ((cpsr s0)[Cbit]) (repr 31)) (Logical_Shift_Right (reg_content s0 m) (repr 1)) else Rotate_Right (reg_content s0 m) shift_imm
      | _ => repr 0
    end in
  do_then [ if_then (ConditionPassed s0 cond)
       (If (zeq U 1)
       then         (set_reg n (add (reg_content s0 n) index))
       else         (set_reg n (sub (reg_content s0 n) index))) ];
  ret_ {{ address }}.

(* A5.3.2 Miscellaneous Loads and Stores - Immediate offset *)
Definition M3_Immediate_offset_step (U : bool) (immedH : word) (immedL : word) (n : regnum) : semfun _ := <s0>
  let offset_8 := or (Logical_Shift_Left immedH (repr 4)) immedL in
  let address := if zeq U 1 then add (reg_content s0 n) offset_8 else sub (reg_content s0 n) offset_8 in
  ret_ {{ address }}.

(* A5.3.3 Miscellaneous Loads and Stores - Register offset *)
Definition M3_Register_offset_step (U : bool) (m : regnum) (n : regnum) : semfun _ := <s0>
  let address := if zeq U 1 then add (reg_content s0 n) (reg_content s0 m) else sub (reg_content s0 n) (reg_content s0 m) in
  ret_ {{ address }}.

(* A5.3.4 Miscellaneous Loads and Stores - Immediate pre indexed *)
Definition M3_Immediate_pre_indexed_step (U : bool) (cond : opcode) (immedH : word) (immedL : word) (n : regnum) : semfun _ := <s0>
  let offset_8 := or (Logical_Shift_Left immedH (repr 4)) immedL in
  let address := if zeq U 1 then add (reg_content s0 n) offset_8 else sub (reg_content s0 n) offset_8 in
  do_then [ if_then (ConditionPassed s0 cond)
       (set_reg n address) ];
  ret_ {{ address }}.

(* A5.3.5 Miscellaneous Loads and Stores - Register pre indexed *)
Definition M3_Register_pre_indexed_step (U : bool) (cond : opcode) (m : regnum) (n : regnum) : semfun _ := <s0>
  let address := if zeq U 1 then add (reg_content s0 n) (reg_content s0 m) else sub (reg_content s0 n) (reg_content s0 m) in
  do_then [ if_then (ConditionPassed s0 cond)
       (set_reg n address) ];
  ret_ {{ address }}.

(* A5.3.6 Miscellaneous Loads and Stores - Immediate post indexed *)
Definition M3_Immediate_post_indexed_step (U : bool) (cond : opcode) (immedH : word) (immedL : word) (n : regnum) : semfun _ := <s0>
  let address := reg_content s0 n in
  let offset_8 := or (Logical_Shift_Left immedH (repr 4)) immedL in
  do_then [ if_then (ConditionPassed s0 cond)
       (If (zeq U 1)
       then         (set_reg n (add (reg_content s0 n) offset_8))
       else         (set_reg n (sub (reg_content s0 n) offset_8))) ];
  ret_ {{ address }}.

(* A5.3.7 Miscellaneous Loads and Stores - Register post indexed *)
Definition M3_Register_post_indexed_step (U : bool) (cond : opcode) (m : regnum) (n : regnum) : semfun _ := <s0>
  let address := reg_content s0 n in
  do_then [ if_then (ConditionPassed s0 cond)
       (If (zeq U 1)
       then         (set_reg n (add (reg_content s0 n) (reg_content s0 m)))
       else         (set_reg n (sub (reg_content s0 n) (reg_content s0 m)))) ];
  ret_ {{ address }}.

(* A5.4.2 Load and Store Multiple - Increment after *)
Definition M4_Increment_after_step (W : bool) (cond : opcode) (n : regnum) (register_list : word) : semfun _ := <s0>
  let start_address := reg_content s0 n in
  let end_address := sub (add (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4))) (repr 4) in
  do_then [ if_then (andb (ConditionPassed s0 cond) (zeq W 1))
       (set_reg n (add (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4)))) ];
  ret_ {{ start_address ; end_address }}.

(* A5.4.3 Load and Store Multiple - Increment before *)
Definition M4_Increment_before_step (W : bool) (cond : opcode) (n : regnum) (register_list : word) : semfun _ := <s0>
  let start_address := add (reg_content s0 n) (repr 4) in
  let end_address := add (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4)) in
  do_then [ if_then (andb (ConditionPassed s0 cond) (zeq W 1))
       (set_reg n (add (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4)))) ];
  ret_ {{ start_address ; end_address }}.

(* A5.4.4 Load and Store Multiple - Decrement after *)
Definition M4_Decrement_after_step (W : bool) (cond : opcode) (n : regnum) (register_list : word) : semfun _ := <s0>
  let start_address := add (sub (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4))) (repr 4) in
  let end_address := reg_content s0 n in
  do_then [ if_then (andb (ConditionPassed s0 cond) (zeq W 1))
       (set_reg n (sub (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4)))) ];
  ret_ {{ start_address ; end_address }}.

(* A5.4.5 Load and Store Multiple - Decrement before *)
Definition M4_Decrement_before_step (W : bool) (cond : opcode) (n : regnum) (register_list : word) : semfun _ := <s0>
  let start_address := sub (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4)) in
  let end_address := sub (reg_content s0 n) (repr 4) in
  do_then [ if_then (andb (ConditionPassed s0 cond) (zeq W 1))
       (set_reg n (sub (reg_content s0 n) (mul (Number_Of_Set_Bits_In register_list) (repr 4)))) ];
  ret_ {{ start_address ; end_address }}.

(* A5.5.2 Load and Store Coprocessor - Immediate offset *)
Definition M5_Immediate_offset_step (U : bool) (cond : opcode) (cp_num : word) (n : regnum) (offset_8 : word) : semfun _ := <s0>
  do_then (@todo unit ComplexSemantics (* if ConditionPassed(cond) then
    begin
    address = if U == 1 then Rn + (offset_8 * 4) else Rn - (offset_8 * 4);
    start_address = address;
    while NotFinished(Coprocessor[cp_num]) do
        address = address + 4;
    end_address = address;
    end *));
  ret_ {{ repr 0 ; repr 0 }}.

(* A5.5.3 Load and Store Coprocessor - Immediate pre indexed *)
Definition M5_Immediate_pre_indexed_step (U : bool) (cond : opcode) (cp_num : word) (n : regnum) (offset_8 : word) : semfun _ := <s0>
  do_then (@todo unit ComplexSemantics (* if ConditionPassed(cond) then
    begin
    if U == 1 then
        Rn = Rn + (offset_8 * 4);
    else Rn = Rn - (offset_8 * 4);
    start_address = Rn;
    address = start_address;
    while NotFinished(Coprocessor[cp_num]) do
        address = address + 4;
    end_address = address;
    end *));
  ret_ {{ repr 0 ; repr 0 }}.

(* A5.5.4 Load and Store Coprocessor - Immediate post indexed *)
Definition M5_Immediate_post_indexed_step (U : bool) (cond : opcode) (cp_num : word) (n : regnum) (offset_8 : word) : semfun _ := <s0>
  do_then (@todo unit ComplexSemantics (* if ConditionPassed(cond) then
    begin
    start_address = Rn;
    if U == 1 then
        Rn = Rn + (offset_8 * 4);
    else Rn = Rn - (offset_8 * 4);
    address = start_address;
    while NotFinished(Coprocessor[cp_num]) do
        address = address + 4;
    end_address = address;
    end *));
  ret_ {{ repr 0 ; repr 0 }}.

(* A5.5.5 Load and Store Coprocessor - Unindexed *)
Definition M5_Unindexed_step (cond : opcode) (cp_num : word) (n : regnum) : semfun _ := <s0>
  do_then (@todo unit ComplexSemantics (* if ConditionPassed(cond) then
    begin
    start_address = Rn;
    address = start_address;
    while NotFinished(Coprocessor[cp_num]) do
        address = address + 4;
    end_address = address;
    end *));
  ret_ {{ repr 0 ; repr 0 }}.

Definition mode_step {A B C} f_mode f : semfun C :=
  do (b, l) <- f_mode;
  apply (if b : bool then NaryFunctions.nfun_to_nfun A _ _ (next conjure_up_true) B f else f) l.

(* Semantic function for addressing mode 1 *)
Definition mode1_step (m : mode1) : _ -> semfun unit := mode_step
  match m with
    | M1_Immediate immed_8 rotate_imm => M1_Immediate_step immed_8 rotate_imm
    | M1_Register m => M1_Register_step m
    | M1_Logical_shift_left_by_immediate m shift_imm => M1_Logical_shift_left_by_immediate_step m shift_imm
    | M1_Logical_shift_left_by_register m s => M1_Logical_shift_left_by_register_step m s
    | M1_Logical_shift_right_by_immediate m shift_imm => M1_Logical_shift_right_by_immediate_step m shift_imm
    | M1_Logical_shift_right_by_register m s => M1_Logical_shift_right_by_register_step m s
    | M1_Arithmetic_shift_right_by_immediate m shift_imm => M1_Arithmetic_shift_right_by_immediate_step m shift_imm
    | M1_Arithmetic_shift_right_by_register m s => M1_Arithmetic_shift_right_by_register_step m s
    | M1_Rotate_right_by_immediate m shift_imm => M1_Rotate_right_by_immediate_step m shift_imm
    | M1_Rotate_right_by_register m s => M1_Rotate_right_by_register_step m s
    | M1_Rotate_right_with_extend m => M1_Rotate_right_with_extend_step m
  end.

(* Semantic function for addressing mode 2 *)
Definition mode2_step (m : mode2) : _ -> semfun unit := mode_step
  match m with
    | M2_Immediate_offset U n offset_12 => M2_Immediate_offset_step U n offset_12
    | M2_Register_offset U m n => M2_Register_offset_step U m n
    | M2_Scaled_register_offset U m n shift_ shift_imm => M2_Scaled_register_offset_step U m n shift_ shift_imm
    | M2_Immediate_pre_indexed U cond n offset_12 => M2_Immediate_pre_indexed_step U cond n offset_12
    | M2_Register_pre_indexed U cond m n => M2_Register_pre_indexed_step U cond m n
    | M2_Scaled_register_pre_indexed U cond m n shift_ shift_imm => M2_Scaled_register_pre_indexed_step U cond m n shift_ shift_imm
    | M2_Immediate_post_indexed U cond n offset_12 => M2_Immediate_post_indexed_step U cond n offset_12
    | M2_Register_post_indexed U cond m n => M2_Register_post_indexed_step U cond m n
    | M2_Scaled_register_post_indexed U cond m n shift_ shift_imm => M2_Scaled_register_post_indexed_step U cond m n shift_ shift_imm
  end.

(* Semantic function for addressing mode 3 *)
Definition mode3_step (m : mode3) : _ -> semfun unit := mode_step
  match m with
    | M3_Immediate_offset U immedH immedL n => M3_Immediate_offset_step U immedH immedL n
    | M3_Register_offset U m n => M3_Register_offset_step U m n
    | M3_Immediate_pre_indexed U cond immedH immedL n => M3_Immediate_pre_indexed_step U cond immedH immedL n
    | M3_Register_pre_indexed U cond m n => M3_Register_pre_indexed_step U cond m n
    | M3_Immediate_post_indexed U cond immedH immedL n => M3_Immediate_post_indexed_step U cond immedH immedL n
    | M3_Register_post_indexed U cond m n => M3_Register_post_indexed_step U cond m n
  end.

(* Semantic function for addressing mode 4 *)
Definition mode4_step (m : mode4) : _ -> semfun unit := mode_step
  match m with
    | M4_Increment_after W cond n register_list => M4_Increment_after_step W cond n register_list
    | M4_Increment_before W cond n register_list => M4_Increment_before_step W cond n register_list
    | M4_Decrement_after W cond n register_list => M4_Decrement_after_step W cond n register_list
    | M4_Decrement_before W cond n register_list => M4_Decrement_before_step W cond n register_list
  end.

(* Semantic function for addressing mode 5 *)
Definition mode5_step (m : mode5) : _ -> semfun unit := mode_step
  match m with
    | M5_Immediate_offset U cond cp_num n offset_8 => M5_Immediate_offset_step U cond cp_num n offset_8
    | M5_Immediate_pre_indexed U cond cp_num n offset_8 => M5_Immediate_pre_indexed_step U cond cp_num n offset_8
    | M5_Immediate_post_indexed U cond cp_num n offset_8 => M5_Immediate_post_indexed_step U cond cp_num n offset_8
    | M5_Unindexed cond cp_num n => M5_Unindexed_step cond cp_num n
  end.

(* Semantic function for instructions *)
Definition step (i : inst) : semfun unit :=
  do_then conjure_up_true;
  match i with
    | ADC m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => ADC_step S_ cond d n shifter_operand)
    | ADD m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => ADD_step S_ cond d n shifter_operand)
    | AND m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => AND_step S_ cond d n shifter_carry_out shifter_operand)
    | B L cond signed_immed_24 => B_step L cond signed_immed_24
    | BIC m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => BIC_step S_ cond d n shifter_carry_out shifter_operand)
    | BKPT => BKPT_step
    | BLX1 H signed_immed_24 => BLX1_step H signed_immed_24
    | BLX2 cond m => BLX2_step cond m
    | BX cond m => BX_step cond m
    | BXJ cond m => BXJ_step cond m
    | CDP cond cp_num => CDP_step cond cp_num
    | CLZ cond d m => CLZ_step cond d m
    | CMN m_ cond n => mode1_step m_ (fun shifter_operand shifter_carry_out => CMN_step cond n shifter_operand)
    | CMP m_ cond n => mode1_step m_ (fun shifter_operand shifter_carry_out => CMP_step cond n shifter_operand)
    | CPS A F I_ imod mmod mode_ => CPS_step A F I_ imod mmod mode_
    | CPY cond d m => CPY_step cond d m
    | EOR m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => EOR_step S_ cond d n shifter_carry_out shifter_operand)
    | LDC m_ cond cp_num => mode5_step m_ (fun start_address end_address => LDC_step cond cp_num start_address)
    | LDM1 m_ cond register_list => mode4_step m_ (fun start_address end_address => LDM1_step cond register_list start_address)
    | LDM2 m_ cond register_list => mode4_step m_ (fun start_address end_address => LDM2_step cond register_list start_address)
    | LDM3 m_ cond register_list => mode4_step m_ (fun start_address end_address => LDM3_step cond register_list start_address)
    | LDR m_ cond d => mode2_step m_ (fun address => LDR_step address cond d)
    | LDRB m_ cond d => mode2_step m_ (fun address => LDRB_step address cond d)
    | LDRBT m_ cond d => mode2_step m_ (fun address => LDRBT_step address cond d)
    | LDRD m_ cond d => mode3_step m_ (fun address => LDRD_step address cond d)
    | LDREX cond d n => LDREX_step cond d n
    | LDRH m_ cond d => mode3_step m_ (fun address => LDRH_step address cond d)
    | LDRSB m_ cond d => mode3_step m_ (fun address => LDRSB_step address cond d)
    | LDRSH m_ cond d => mode3_step m_ (fun address => LDRSH_step address cond d)
    | LDRT m_ cond d => mode2_step m_ (fun address => LDRT_step address cond d)
    | MCR cond cp_num d => MCR_step cond cp_num d
    | MCRR cond cp_num d n => MCRR_step cond cp_num d n
    | MLA S_ cond d m n s => MLA_step S_ cond d m n s
    | MOV m_ S_ cond d => mode1_step m_ (fun shifter_operand shifter_carry_out => MOV_step S_ cond d shifter_carry_out shifter_operand)
    | MRC cond cp_num d => MRC_step cond cp_num d
    | MRRC cond cp_num d n => MRRC_step cond cp_num d n
    | MRS R_ cond d => MRS_step R_ cond d
    | MSRimm R_ cond field_mask immed_8 rotate_imm => MSRimm_step R_ cond field_mask immed_8 rotate_imm
    | MSRreg R_ cond field_mask m => MSRreg_step R_ cond field_mask m
    | MUL S_ cond d m s => MUL_step S_ cond d m s
    | MVN m_ S_ cond d => mode1_step m_ (fun shifter_operand shifter_carry_out => MVN_step S_ cond d shifter_carry_out shifter_operand)
    | ORR m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => ORR_step S_ cond d n shifter_carry_out shifter_operand)
    | PKHBT cond d m n shift_imm => PKHBT_step cond d m n shift_imm
    | PKHTB cond d m n shift_imm => PKHTB_step cond d m n shift_imm
    | PLD => PLD_step
    | QADD cond d m n => QADD_step cond d m n
    | QADD16 cond d m n => QADD16_step cond d m n
    | QADD8 cond d m n => QADD8_step cond d m n
    | QADDSUBX cond d m n => QADDSUBX_step cond d m n
    | QDADD cond d m n => QDADD_step cond d m n
    | QDSUB cond d m n => QDSUB_step cond d m n
    | QSUB cond d m n => QSUB_step cond d m n
    | QSUB16 cond d m n => QSUB16_step cond d m n
    | QSUB8 cond d m n => QSUB8_step cond d m n
    | QSUBADDX cond d m n => QSUBADDX_step cond d m n
    | REV cond d m => REV_step cond d m
    | REV16 cond d m => REV16_step cond d m
    | REVSH cond d m => REVSH_step cond d m
    | RFE m_ => mode4_step m_ (fun start_address end_address => RFE_step start_address)
    | RSB m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => RSB_step S_ cond d n shifter_operand)
    | RSC m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => RSC_step S_ cond d n shifter_operand)
    | SADD16 cond d m n => SADD16_step cond d m n
    | SADD8 cond d m n => SADD8_step cond d m n
    | SADDSUBX cond d m n => SADDSUBX_step cond d m n
    | SBC m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => SBC_step S_ cond d n shifter_operand)
    | SEL cond d m n => SEL_step cond d m n
    | SETEND E => SETEND_step E
    | SHADD16 cond d m n => SHADD16_step cond d m n
    | SHADD8 cond d m n => SHADD8_step cond d m n
    | SHADDSUBX cond d m n => SHADDSUBX_step cond d m n
    | SHSUB16 cond d m n => SHSUB16_step cond d m n
    | SHSUB8 cond d m n => SHSUB8_step cond d m n
    | SHSUBADDX cond d m n => SHSUBADDX_step cond d m n
    | SMLAxy cond d m n s x y => SMLAxy_step cond d m n s x y
    | SMLAD X cond d m n s => SMLAD_step X cond d m n s
    | SMLAL S_ cond dHi dLo m s => SMLAL_step S_ cond dHi dLo m s
    | SMLALxy cond dHi dLo m s x y => SMLALxy_step cond dHi dLo m s x y
    | SMLALD X cond dHi dLo m s => SMLALD_step X cond dHi dLo m s
    | SMLAWy cond d m n s y => SMLAWy_step cond d m n s y
    | SMLSD X cond d m n s => SMLSD_step X cond d m n s
    | SMLSLD X cond dHi dLo m s => SMLSLD_step X cond dHi dLo m s
    | SMMLA R_ cond d m n s => SMMLA_step R_ cond d m n s
    | SMMLS R_ cond d m n s => SMMLS_step R_ cond d m n s
    | SMMUL R_ cond d m s => SMMUL_step R_ cond d m s
    | SMUAD X cond d m s => SMUAD_step X cond d m s
    | SMULxy cond d m s x y => SMULxy_step cond d m s x y
    | SMULL S_ cond dHi dLo m s => SMULL_step S_ cond dHi dLo m s
    | SMULWy cond d m s y => SMULWy_step cond d m s y
    | SMUSD X cond d m s => SMUSD_step X cond d m s
    | SRS m_ => mode4_step m_ (fun start_address end_address => SRS_step start_address)
    | SSAT cond d m sat_imm shift_ shift_imm => SSAT_step cond d m sat_imm shift_ shift_imm
    | SSAT16 cond d m sat_imm => SSAT16_step cond d m sat_imm
    | SSUB16 cond d m n => SSUB16_step cond d m n
    | SSUB8 cond d m n => SSUB8_step cond d m n
    | SSUBADDX cond d m n => SSUBADDX_step cond d m n
    | STC m_ cond cp_num => mode5_step m_ (fun start_address end_address => STC_step cond cp_num start_address)
    | STM1 m_ cond register_list => mode4_step m_ (fun start_address end_address => STM1_step cond register_list start_address)
    | STM2 m_ cond register_list => mode4_step m_ (fun start_address end_address => STM2_step cond register_list start_address)
    | STR m_ cond d => mode2_step m_ (fun address => STR_step address cond d)
    | STRB m_ cond d => mode2_step m_ (fun address => STRB_step address cond d)
    | STRBT m_ cond d => mode2_step m_ (fun address => STRBT_step address cond d)
    | STRD m_ cond d => mode3_step m_ (fun address => STRD_step address cond d)
    | STREX cond d m n => STREX_step cond d m n
    | STRH m_ cond d => mode3_step m_ (fun address => STRH_step address cond d)
    | STRT m_ cond d => mode2_step m_ (fun address => STRT_step address cond d)
    | SUB m_ S_ cond d n => mode1_step m_ (fun shifter_operand shifter_carry_out => SUB_step S_ cond d n shifter_operand)
    | SWI cond => SWI_step cond
    | SWP cond d m n => SWP_step cond d m n
    | SWPB cond d m n => SWPB_step cond d m n
    | SXTAB cond d m n rotate => SXTAB_step cond d m n rotate
    | SXTAB16 cond d m n rotate => SXTAB16_step cond d m n rotate
    | SXTAH cond d m n rotate => SXTAH_step cond d m n rotate
    | SXTB cond d m rotate => SXTB_step cond d m rotate
    | SXTB16 cond d m rotate => SXTB16_step cond d m rotate
    | SXTH cond d m rotate => SXTH_step cond d m rotate
    | TEQ m_ cond n => mode1_step m_ (fun shifter_operand shifter_carry_out => TEQ_step cond n shifter_carry_out shifter_operand)
    | TST m_ cond n => mode1_step m_ (fun shifter_operand shifter_carry_out => TST_step cond n shifter_carry_out shifter_operand)
    | UADD16 cond d m n => UADD16_step cond d m n
    | UADD8 cond d m n => UADD8_step cond d m n
    | UADDSUBX cond d m n => UADDSUBX_step cond d m n
    | UHADD16 cond d m n => UHADD16_step cond d m n
    | UHADD8 cond d m n => UHADD8_step cond d m n
    | UHADDSUBX cond d m n => UHADDSUBX_step cond d m n
    | UHSUB16 cond d m n => UHSUB16_step cond d m n
    | UHSUB8 cond d m n => UHSUB8_step cond d m n
    | UHSUBADDX cond d m n => UHSUBADDX_step cond d m n
    | UMAAL cond dHi dLo m s => UMAAL_step cond dHi dLo m s
    | UMLAL S_ cond dHi dLo m s => UMLAL_step S_ cond dHi dLo m s
    | UMULL S_ cond dHi dLo m s => UMULL_step S_ cond dHi dLo m s
    | UQADD16 cond d m n => UQADD16_step cond d m n
    | UQADD8 cond d m n => UQADD8_step cond d m n
    | UQADDSUBX cond d m n => UQADDSUBX_step cond d m n
    | UQSUB16 cond d m n => UQSUB16_step cond d m n
    | UQSUB8 cond d m n => UQSUB8_step cond d m n
    | UQSUBADDX cond d m n => UQSUBADDX_step cond d m n
    | USAD8 cond d m s => USAD8_step cond d m s
    | USADA8 cond d m n s => USADA8_step cond d m n s
    | USAT cond d m sat_imm shift_ shift_imm => USAT_step cond d m sat_imm shift_ shift_imm
    | USAT16 cond d m sat_imm => USAT16_step cond d m sat_imm
    | USUB16 cond d m n => USUB16_step cond d m n
    | USUB8 cond d m n => USUB8_step cond d m n
    | USUBADDX cond d m n => USUBADDX_step cond d m n
    | UXTAB cond d m n rotate => UXTAB_step cond d m n rotate
    | UXTAB16 cond d m n rotate => UXTAB16_step cond d m n rotate
    | UXTAH cond d m n rotate => UXTAH_step cond d m n rotate
    | UXTB cond d m rotate => UXTB_step cond d m rotate
    | UXTB16 cond d m rotate => UXTB16_step cond d m rotate
    | UXTH cond d m rotate => UXTH_step cond d m rotate
end.

End InstSem.
