(**
SimSoC-Cert, a toolkit for generating certified processor simulators
See the COPYRIGHTS and LICENSE files.

Coq representation of a C program automatically generated by Simgen.
*)

Require Import ZArith Cnotations.

Open Scope Z_scope.

(* identifiers *)

Open Scope positive_scope.
Definition hi := 1.
Definition lo := 2.
Definition struct___int64 := 3.
Definition mem := 4.
Definition _end := 5.
Definition size := 6.
Definition begin := 7.
Definition SLv6_MMU := 8.
Definition background := 9.
Definition mode := 10.
Definition T_flag := 11.
Definition F_flag := 12.
Definition I_flag := 13.
Definition A_flag := 14.
Definition E_flag := 15.
Definition GE3 := 16.
Definition GE2 := 17.
Definition GE1 := 18.
Definition GE0 := 19.
Definition J_flag := 20.
Definition Q_flag := 21.
Definition V_flag := 22.
Definition C_flag := 23.
Definition Z_flag := 24.
Definition N_flag := 25.
Definition SLv6_StatusRegister := 26.
Definition v_bit := 27.
Definition u_bit := 28.
Definition ee_bit := 29.
Definition SLv6_SystemCoproc := 30.
Definition jump := 31.
Definition pc := 32.
Definition und_regs := 33.
Definition abt_regs := 34.
Definition svc_regs := 35.
Definition irq_regs := 36.
Definition fiq_regs := 37.
Definition user_regs := 38.
Definition id := 39.
Definition cp15 := 40.
Definition spsrs := 41.
Definition cpsr := 42.
Definition mmu_ptr := 43.
Definition SLv6_Processor := 44.
Definition gvars := 45.
Definition main := 46.
Definition signed_immed_24 := 47.
Definition cond := 48.
Definition L := 49.
Definition SignExtend_30 := 50.
Definition proc := 51.
Definition reg := 52.
Definition set_pc_raw := 53.
Definition address_of_next_instruction := 54.
Definition set_reg := 55.
Definition ConditionPassed := 56.
Definition B := 57.
Close Scope positive_scope.

(* structs and unions *)

Definition typ_struct_SLv6_SystemCoproc := 
F[
  ee_bit -: uint8; 
  u_bit -: uint8; 
  v_bit -: uint8].

Definition typ_SLv6_SystemCoproc := Tstruct SLv6_SystemCoproc typ_struct_SLv6_SystemCoproc.

Definition typ_struct_SLv6_StatusRegister := 
F[
  N_flag -: uint8; 
  Z_flag -: uint8; 
  C_flag -: uint8; 
  V_flag -: uint8; 
  Q_flag -: uint8; 
  J_flag -: uint8; 
  GE0 -: uint8; 
  GE1 -: uint8; 
  GE2 -: uint8; 
  GE3 -: uint8; 
  E_flag -: uint8; 
  A_flag -: uint8; 
  I_flag -: uint8; 
  F_flag -: uint8; 
  T_flag -: uint8; 
  mode -: int32; 
  background -: uint32].

Definition typ_SLv6_StatusRegister := Tstruct SLv6_StatusRegister typ_struct_SLv6_StatusRegister.

Definition typ_struct_SLv6_MMU := 
F[
  begin -: uint32; 
  size -: uint32; 
  _end -: uint32; 
  mem -: `*` uint8].

Definition typ_SLv6_MMU := Tstruct SLv6_MMU typ_struct_SLv6_MMU.

Definition typ_struct_SLv6_Processor := 
F[
  mmu_ptr -: `*` typ_SLv6_MMU; 
  cpsr -: typ_SLv6_StatusRegister; 
  spsrs -: Tarray typ_SLv6_StatusRegister 5; 
  cp15 -: typ_SLv6_SystemCoproc; 
  id -: uint32; 
  user_regs -: Tarray uint32 16; 
  fiq_regs -: Tarray uint32 7; 
  irq_regs -: Tarray uint32 2; 
  svc_regs -: Tarray uint32 2; 
  abt_regs -: Tarray uint32 2; 
  und_regs -: Tarray uint32 2; 
  pc -: `*` uint32; 
  jump -: uint8].

Definition typ_SLv6_Processor := Tstruct SLv6_Processor typ_struct_SLv6_Processor.

(* expression types *)

Definition T1 := Tfunction T[`*` typ_SLv6_StatusRegister; int32] int8.
Definition T2 := `*` typ_SLv6_Processor.
Definition T3 := typ_SLv6_Processor.
Definition T4 := typ_SLv6_StatusRegister.
Definition T5 := `*` typ_SLv6_StatusRegister.
Definition T6 := int32.
Definition T7 := int8.
Definition T8 := Tfunction T[`*` typ_SLv6_Processor; uint8; uint32] void.
Definition T9 := Tfunction T[`*` typ_SLv6_Processor] uint32.
Definition T10 := uint32.
Definition T11 := void.
Definition T12 := Tfunction T[`*` typ_SLv6_Processor; uint32] void.
Definition T13 := Tfunction T[`*` typ_SLv6_Processor; uint8] uint32.
Definition T14 := Tfunction T[uint32] uint32.

(* global variables *)

Definition gv_gvars :=
  {| gvar_info := Tarray uint8 0;
     gvar_init := [Init_int8 0];
     gvar_readonly := false;
     gvar_volatile := false |}.

Definition global_variables : list (prod ident (globvar type)) := [(gvars,gv_gvars)].

(* functions *)

Definition fun_internal_B :=
  {| fn_return := void;
     fn_params := [
proc -: `*` typ_SLv6_Processor; 
L -: int8; 
cond -: int32; 
signed_immed_24 -: uint32];
     fn_vars := [];
     fn_body :=
`if (call (\ConditionPassed`:T1) E[&((`*(\proc`:T2)`:T3)|cpsr`:T4)`:T5; \cond`:T6] T7)
then `if ((\L`:T7)==(#1`:T6)`:T6)
then (call (\set_reg`:T8) E[\proc`:T2; #14`:T6; (call (\address_of_next_instruction`:T9) E[\proc`:T2] T10)] T11)
else skip;;
(call (\set_pc_raw`:T12) E[\proc`:T2; (call (\reg`:T13) E[\proc`:T2; #15`:T6] T10)+((call (\SignExtend_30`:T14) E[\signed_immed_24`:T10] T10)<<(#2`:T6)`:T10)`:T10] T11)
else skip |}.

Definition fun_B :=
  (B, Internal fun_internal_B).

Definition functions : list (prod ident fundef) := [fun_B].

(* program *)

Definition p :=
  {| prog_funct := functions;
     prog_main := main;
     prog_vars := global_variables |}.
