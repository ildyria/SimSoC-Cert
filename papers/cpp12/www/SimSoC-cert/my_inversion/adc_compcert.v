(**
SimSoC-Cert, a toolkit for generating certified processor simulators
See the COPYRIGHTS and LICENSE files.

Coq representation of a C program automatically generated by Simgen.
*)

Require Import ZArith Cnotations.

Open Scope Z_scope.

(* identifiers *)

Open Scope positive_scope.
Definition hi := 1.
Definition lo := 2.
Definition struct___int64 := 3.
Definition mem := 4.
Definition _end := 5.
Definition size := 6.
Definition begin := 7.
Definition SLv6_MMU := 8.
Definition background := 9.
Definition mode := 10.
Definition T_flag := 11.
Definition F_flag := 12.
Definition I_flag := 13.
Definition A_flag := 14.
Definition E_flag := 15.
Definition GE3 := 16.
Definition GE2 := 17.
Definition GE1 := 18.
Definition GE0 := 19.
Definition J_flag := 20.
Definition Q_flag := 21.
Definition V_flag := 22.
Definition C_flag := 23.
Definition Z_flag := 24.
Definition N_flag := 25.
Definition SLv6_StatusRegister := 26.
Definition v_bit := 27.
Definition u_bit := 28.
Definition ee_bit := 29.
Definition SLv6_SystemCoproc := 30.
Definition jump := 31.
Definition pc := 32.
Definition und_regs := 33.
Definition abt_regs := 34.
Definition svc_regs := 35.
Definition irq_regs := 36.
Definition fiq_regs := 37.
Definition user_regs := 38.
Definition id := 39.
Definition cp15 := 40.
Definition spsrs := 41.
Definition cpsr := 42.
Definition mmu_ptr := 43.
Definition SLv6_Processor := 44.
Definition gvars := 45.
Definition main := 46.
Definition shifter_operand := 47.
Definition n := 48.
Definition d := 49.
Definition cond := 50.
Definition S := 51.
Definition old_Rn := 52.
Definition proc := 53.
Definition OverflowFrom_add3 := 54.
Definition CarryFrom_add3 := 55.
Definition reg := 56.
Definition get_bit := 57.
Definition unpredictable := 58.
Definition spsr := 59.
Definition copy_StatusRegister := 60.
Definition CurrentModeHasSPSR := 61.
Definition set_reg_or_pc := 62.
Definition ConditionPassed := 63.
Definition ADC := 64.

(* manually add ident *)
Definition addr_of_reg_m := 65.
Definition m := 66.
Definition reg_id := 67.
Definition reg_m := 68.
Definition x := 69.

Close Scope positive_scope.

(* structs and unions *)

Definition typ_struct_SLv6_SystemCoproc := 
F[
  ee_bit -: uint8; 
  u_bit -: uint8; 
  v_bit -: uint8].

Definition typ_SLv6_SystemCoproc := Tstruct SLv6_SystemCoproc typ_struct_SLv6_SystemCoproc.

Definition typ_struct_SLv6_StatusRegister := 
F[
  N_flag -: uint8; 
  Z_flag -: uint8; 
  C_flag -: uint8; 
  V_flag -: uint8; 
  Q_flag -: uint8; 
  J_flag -: uint8; 
  GE0 -: uint8; 
  GE1 -: uint8; 
  GE2 -: uint8; 
  GE3 -: uint8; 
  E_flag -: uint8; 
  A_flag -: uint8; 
  I_flag -: uint8; 
  F_flag -: uint8; 
  T_flag -: uint8; 
  mode -: int32; 
  background -: uint32].

Definition typ_SLv6_StatusRegister := Tstruct SLv6_StatusRegister typ_struct_SLv6_StatusRegister.

Definition typ_struct_SLv6_MMU := 
F[
  begin -: uint32; 
  size -: uint32; 
  _end -: uint32; 
  mem -: `*` uint8].

Definition typ_SLv6_MMU := Tstruct SLv6_MMU typ_struct_SLv6_MMU.

Definition typ_struct_SLv6_Processor := 
F[
  mmu_ptr -: `*` typ_SLv6_MMU; 
  cpsr -: typ_SLv6_StatusRegister; 
  spsrs -: Tarray typ_SLv6_StatusRegister 5; 
  cp15 -: typ_SLv6_SystemCoproc; 
  id -: uint32; 
  user_regs -: Tarray uint32 16; 
  fiq_regs -: Tarray uint32 7; 
  irq_regs -: Tarray uint32 2; 
  svc_regs -: Tarray uint32 2; 
  abt_regs -: Tarray uint32 2; 
  und_regs -: Tarray uint32 2; 
  pc -: `*` uint32; 
  jump -: uint8].

Definition typ_SLv6_Processor := Tstruct SLv6_Processor typ_struct_SLv6_Processor.

(* expression types *)

Definition T1 := uint32.
Definition T2 := Tfunction T[`*` typ_SLv6_Processor; uint8] uint32.
Definition T3 := `*` typ_SLv6_Processor.
Definition T4 := uint8.
Definition T5 := Tfunction T[`*` typ_SLv6_StatusRegister; int32] int8.
Definition T6 := typ_SLv6_Processor.
Definition T7 := typ_SLv6_StatusRegister.
Definition T8 := `*` typ_SLv6_StatusRegister.
Definition T9 := int32.
Definition T10 := int8.
Definition T11 := Tfunction T[`*` typ_SLv6_Processor; uint8; uint32] void.
Definition T12 := void.
Definition T13 := Tfunction T[`*` typ_SLv6_Processor] int8.
Definition T14 := Tfunction T[`*` typ_SLv6_StatusRegister; `*` typ_SLv6_StatusRegister] void.
Definition T15 := Tfunction T[`*` typ_SLv6_Processor] (`*` typ_SLv6_StatusRegister).
Definition T16 := Tfunction T[] void.
Definition T17 := Tfunction T[uint32; uint32] int8.
Definition T18 := Tfunction T[uint32; uint32; uint32] int8.
Definition T19 := Tfunction T[uint32; uint32; int8] int8.

(* manually add type definition *)
Definition T20 := Tfunction T[`*` typ_SLv6_Processor; uint8; int32] (`*` uint32).
Definition T21 := `*` uint32.
Definition T22 := Tfunction T[`*` typ_SLv6_Processor; uint8; int32] uint32.


(* global variables *)

Definition gv_gvars :=
  {| gvar_info := Tarray uint8 0;
     gvar_init := [Init_int8 0];
     gvar_readonly := false;
     gvar_volatile := false |}.

Definition global_variables : list (prod ident (globvar type)) := [(gvars,gv_gvars)].

(* functions *)

Definition fun_internal_ADC :=
  {| fn_return := void;
     fn_params := [
proc -: `*` typ_SLv6_Processor; 
S -: int8; 
cond -: int32; 
d -: uint8; 
n -: uint8; 
shifter_operand -: uint32];
     fn_vars := [
old_Rn -: uint32];
     fn_body :=
($ old_Rn`:T1) `= (call (\reg`:T2) E[\proc`:T3; \n`:T4] T1)`:T1;;
`if (call (\ConditionPassed`:T5) E[&((`*(\proc`:T3)`:T6)|cpsr`:T7)`:T8; \cond`:T9] T10)
then (call (\set_reg_or_pc`:T11) E[\proc`:T3; \d`:T4; ((\old_Rn`:T1)+(\shifter_operand`:T1)`:T1)+(valof (((`*(\proc`:T3)`:T6)|cpsr`:T7)|C_flag`:T10) T10)`:T10] T12);;
`if (((\S`:T10)==(#1`:T9)`:T9)?(((\d`:T4)==(#15`:T9)`:T9)?(#1`:T9)`:(#0`:T9)`:T9)`:(#0`:T9)`:T9)
then `if (call (\CurrentModeHasSPSR`:T13) E[\proc`:T3] T10)
then (call (\copy_StatusRegister`:T14) E[&((`*(\proc`:T3)`:T6)|cpsr`:T7)`:T8; (call (\spsr`:T15) E[\proc`:T3] T8)] T12)
else (call (\unpredictable`:T16) E[] T12)
else `if ((\S`:T10)==(#1`:T9)`:T9)
then (((`*(\proc`:T3)`:T6)|cpsr`:T7)|N_flag`:T10) `= (call (\get_bit`:T17) E[(call (\reg`:T2) E[\proc`:T3; \d`:T4] T1); #31`:T9] T10)`:T10;;
(((`*(\proc`:T3)`:T6)|cpsr`:T7)|Z_flag`:T10) `= (((call (\reg`:T2) E[\proc`:T3; \d`:T4] T1)==(#0`:T9)`:T9)?(#1`:T9)`:(#0`:T9)`:T9)`:T10;;
(((`*(\proc`:T3)`:T6)|cpsr`:T7)|C_flag`:T10) `= (call (\CarryFrom_add3`:T18) E[\old_Rn`:T1; \shifter_operand`:T1; (valof (((`*(\proc`:T3)`:T6)|cpsr`:T7)|C_flag`:T10) T10)] T10)`:T10;;
(((`*(\proc`:T3)`:T6)|cpsr`:T7)|V_flag`:T10) `= (call (\OverflowFrom_add3`:T19) E[\old_Rn`:T1; \shifter_operand`:T1; (valof (((`*(\proc`:T3)`:T6)|cpsr`:T7)|C_flag`:T10) T10)] T10)`:T10
else skip
else skip |}.

Definition fun_ADC :=
  (ADC, Internal fun_internal_ADC).

(* manually add functions *)
Definition fun_ConditionPassed :=
  (ConditionPassed, External
  (EF_external ConditionPassed {| sig_args := [AST.Tint; AST.Tint]; sig_res := Some AST.Tint |})
  T[`*` typ_SLv6_StatusRegister; int32]
  int8).

Definition fun_copy_StatusRegister :=
  (copy_StatusRegister, External
  (EF_external copy_StatusRegister {| sig_args := [AST.Tint; AST.Tint]; sig_res := None |})
  T[`*` typ_SLv6_StatusRegister; `*` typ_SLv6_StatusRegister]
  void).

Definition fun_addr_of_reg_m :=
  (addr_of_reg_m, External
  (EF_external addr_of_reg_m {| sig_args := [AST.Tint; AST.Tint; AST.Tint]; sig_res := Some AST.Tint |})
  T[`*` typ_SLv6_Processor; uint8; int32]
  (`*` uint32)).

Definition fun_internal_reg_m :=
  {| fn_return := uint32;
     fn_params := [
proc -: `*` typ_SLv6_Processor; 
reg_id -: uint8; 
m -: int32];
     fn_vars := [];
     fn_body :=
return (Some (valof (`*(call (\addr_of_reg_m`:T20) E[\proc`:T3; \reg_id`:T4; \m`:T9] T21)`:T1) T1)) |}.

Definition fun_reg_m :=
  (reg_m, Internal fun_internal_reg_m).

Definition fun_internal_reg :=
  {| fn_return := uint32;
     fn_params := [
proc -: `*` typ_SLv6_Processor; 
reg_id -: uint8];
     fn_vars := [];
     fn_body :=
return (Some (call (\reg_m`:T22) E[\proc`:T3; \reg_id`:T4; (valof (((`*(\proc`:T3)`:T6)|cpsr`:T7)|mode`:T9) T9)] T1)) |}.

Definition fun_reg :=
  (reg, Internal fun_internal_reg).

Definition fun_internal_CurrentModeHasSPSR :=
  {| fn_return := int8;
     fn_params := [
proc -: `*` typ_SLv6_Processor];
     fn_vars := [];
     fn_body :=
return (Some ((valof (((`*(\proc`:T3)`:T6)|cpsr`:T7)|mode`:T9) T9)<(#5`:T9)`:T9)) |}.

Definition fun_CurrentModeHasSPSR :=
  (CurrentModeHasSPSR, Internal fun_internal_CurrentModeHasSPSR).

Definition fun_internal_get_bit :=
  {| fn_return := int8;
     fn_params := [
x -: uint32; 
n -: uint32];
     fn_vars := [];
     fn_body :=
return (Some (((\x`:T1)>>(\n`:T1)`:T1)&(#1`:T9)`:T1)) |}.

Definition fun_get_bit :=
  (get_bit, Internal fun_internal_get_bit).

(* manually changed functions list *)
(*Definition functions : list (prod ident fundef) := [fun_ADC].*)
Definition functions : list (prod ident fundef) :=
  [fun_ConditionPassed; fun_copy_StatusRegister; fun_addr_of_reg_m; fun_reg_m; fun_reg; fun_CurrentModeHasSPSR; fun_get_bit; fun_ADC].

(* program *)

Definition p :=
  {| prog_funct := functions;
     prog_main := main;
     prog_vars := global_variables |}.
